{"ast":null,"code":"export function nQueensAlgorithm(grid, nodesToAnimate, size = 8) {\n  const boardSize = size;\n  const queens = []; // Reset grid statuses first\n\n  for (let row = 0; row < boardSize; row++) {\n    for (let col = 0; col < boardSize; col++) {\n      grid[row][col].status = \"unvisited\";\n    }\n  }\n\n  function isSafe(row, col) {\n    for (let i = 0; i < queens.length; i++) {\n      const [qRow, qCol] = queens[i];\n      if (qCol === col || // Same column\n      qRow - qCol === row - col || // Same diagonal\n      qRow + qCol === row + col // Same anti-diagonal\n      ) return false;\n    }\n\n    return true;\n  }\n\n  function solve(row = 0) {\n    if (row === boardSize) return true;\n\n    for (let col = 0; col < boardSize; col++) {\n      if (isSafe(row, col)) {\n        queens.push([row, col]);\n        let node = grid[row][col];\n        node.status = \"queen\";\n        nodesToAnimate.push({ ...node\n        }); // Push a copy to avoid reference issues\n\n        if (solve(row + 1)) return true; // Backtrack\n\n        queens.pop();\n        node.status = \"visited\"; // Mark as visited but not a queen\n\n        nodesToAnimate.push({ ...node\n        });\n      }\n    }\n\n    return false;\n  }\n\n  solve();\n  return \"done\";\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/nQueens.js"],"names":["nQueensAlgorithm","grid","nodesToAnimate","size","boardSize","queens","row","col","status","isSafe","i","length","qRow","qCol","solve","push","node","pop"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,cAAhC,EAAgDC,IAAI,GAAG,CAAvD,EAA0D;AAC/D,QAAMC,SAAS,GAAGD,IAAlB;AACA,QAAME,MAAM,GAAG,EAAf,CAF+D,CAI/D;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,SAAxB,EAAmCE,GAAG,EAAtC,EAA0C;AACxC,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACxCN,MAAAA,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,GAAwB,WAAxB;AACD;AACF;;AAED,WAASC,MAAT,CAAgBH,GAAhB,EAAqBC,GAArB,EAA0B;AACxB,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,YAAM,CAACE,IAAD,EAAOC,IAAP,IAAeR,MAAM,CAACK,CAAD,CAA3B;AACA,UACEG,IAAI,KAAKN,GAAT,IAA0B;AAC1BK,MAAAA,IAAI,GAAGC,IAAP,KAAgBP,GAAG,GAAGC,GADtB,IAC6B;AAC7BK,MAAAA,IAAI,GAAGC,IAAP,KAAgBP,GAAG,GAAGC,GAHxB,CAG+B;AAH/B,QAIE,OAAO,KAAP;AACH;;AACD,WAAO,IAAP;AACD;;AAED,WAASO,KAAT,CAAeR,GAAG,GAAG,CAArB,EAAwB;AACtB,QAAIA,GAAG,KAAKF,SAAZ,EAAuB,OAAO,IAAP;;AAEvB,SAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACxC,UAAIE,MAAM,CAACH,GAAD,EAAMC,GAAN,CAAV,EAAsB;AACpBF,QAAAA,MAAM,CAACU,IAAP,CAAY,CAACT,GAAD,EAAMC,GAAN,CAAZ;AACA,YAAIS,IAAI,GAAGf,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,CAAX;AACAS,QAAAA,IAAI,CAACR,MAAL,GAAc,OAAd;AACAN,QAAAA,cAAc,CAACa,IAAf,CAAoB,EAAC,GAAGC;AAAJ,SAApB,EAJoB,CAIY;;AAEhC,YAAIF,KAAK,CAACR,GAAG,GAAG,CAAP,CAAT,EAAoB,OAAO,IAAP,CANA,CAQpB;;AACAD,QAAAA,MAAM,CAACY,GAAP;AACAD,QAAAA,IAAI,CAACR,MAAL,GAAc,SAAd,CAVoB,CAUK;;AACzBN,QAAAA,cAAc,CAACa,IAAf,CAAoB,EAAC,GAAGC;AAAJ,SAApB;AACD;AACF;;AACD,WAAO,KAAP;AACD;;AAEDF,EAAAA,KAAK;AACL,SAAO,MAAP;AACD","sourcesContent":["export function nQueensAlgorithm(grid, nodesToAnimate, size = 8) {\r\n  const boardSize = size;\r\n  const queens = [];\r\n  \r\n  // Reset grid statuses first\r\n  for (let row = 0; row < boardSize; row++) {\r\n    for (let col = 0; col < boardSize; col++) {\r\n      grid[row][col].status = \"unvisited\";\r\n    }\r\n  }\r\n\r\n  function isSafe(row, col) {\r\n    for (let i = 0; i < queens.length; i++) {\r\n      const [qRow, qCol] = queens[i];\r\n      if (\r\n        qCol === col ||           // Same column\r\n        qRow - qCol === row - col || // Same diagonal\r\n        qRow + qCol === row + col    // Same anti-diagonal\r\n      ) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function solve(row = 0) {\r\n    if (row === boardSize) return true;\r\n\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (isSafe(row, col)) {\r\n        queens.push([row, col]);\r\n        let node = grid[row][col];\r\n        node.status = \"queen\";\r\n        nodesToAnimate.push({...node}); // Push a copy to avoid reference issues\r\n        \r\n        if (solve(row + 1)) return true;\r\n\r\n        // Backtrack\r\n        queens.pop();\r\n        node.status = \"visited\"; // Mark as visited but not a queen\r\n        nodesToAnimate.push({...node});\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  solve();\r\n  return \"done\";\r\n}"]},"metadata":{},"sourceType":"module"}