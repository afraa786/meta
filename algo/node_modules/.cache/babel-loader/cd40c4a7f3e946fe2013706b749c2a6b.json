{"ast":null,"code":"export function unweightedSearchAlgorithm(grid, start, target, nodesToAnimate, name) {\n  // Input validation\n  if (!grid || !start || !target) {\n    console.error(\"Invalid grid or nodes\");\n    return false;\n  }\n\n  let structure = [start];\n  let exploredNodes = {\n    [start.id]: true\n  }; // Use bracket notation for dynamic keys\n\n  while (structure.length) {\n    let currentNode = name === \"BFS\" ? structure.shift() : structure.pop(); // Validate current node\n\n    if (!currentNode || currentNode.row === undefined || currentNode.col === undefined) {\n      continue;\n    }\n\n    nodesToAnimate.push(currentNode);\n    currentNode.status = \"visited\"; // Ending condition\n\n    if (currentNode.id === target.id) return \"success!\"; // Get and process neighbors\n\n    let currentNeighbors = getNeighbors(currentNode, grid, name);\n    currentNeighbors.forEach(neighbor => {\n      if (!neighbor || !neighbor.id) return; // Skip invalid neighbors\n\n      if (!exploredNodes[neighbor.id]) {\n        if (name === \"BFS\") exploredNodes[neighbor.id] = true;\n\n        if (neighbor.id !== start.id) {\n          neighbor.previousNode = currentNode;\n        } // Only push valid neighbors that are within grid bounds\n\n\n        if (neighbor.row >= 0 && neighbor.row < grid.length && neighbor.col >= 0 && neighbor.col < grid[0].length) {\n          structure.push(neighbor);\n        }\n      }\n    });\n  }\n\n  return false;\n}\n\nfunction getNeighbors(node, grid, name) {\n  const neighbors = [];\n  if (!node || !grid) return neighbors;\n  const {\n    col,\n    row\n  } = node; // Check grid boundaries safely\n\n  if (row > 0) {\n    addNeighbor(grid[row - 1][col], neighbors, name);\n  }\n\n  if (row < grid.length - 1) {\n    addNeighbor(grid[row + 1][col], neighbors, name);\n  }\n\n  if (col > 0) {\n    addNeighbor(grid[row][col - 1], neighbors, name);\n  }\n\n  if (col < grid[0].length - 1) {\n    addNeighbor(grid[row][col + 1], neighbors, name);\n  } // Fixed typo: stutus → status\n\n\n  return neighbors.filter(neighbor => neighbor && neighbor.status !== \"visited\" && neighbor.status !== \"wall\");\n}\n\nfunction addNeighbor(neighbor, neighbors, name) {\n  if (!neighbor) return;\n\n  if (name === \"BFS\") {\n    neighbors.push(neighbor);\n  } else {\n    neighbors.unshift(neighbor);\n  }\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/unweightedSearchAlgorithm.js"],"names":["unweightedSearchAlgorithm","grid","start","target","nodesToAnimate","name","console","error","structure","exploredNodes","id","length","currentNode","shift","pop","row","undefined","col","push","status","currentNeighbors","getNeighbors","forEach","neighbor","previousNode","node","neighbors","addNeighbor","filter","unshift"],"mappings":"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","sourcesContent":["export function unweightedSearchAlgorithm(grid, start, target, nodesToAnimate, name) {\r\n    // Input validation\r\n    if (!grid || !start || !target) {\r\n        console.error(\"Invalid grid or nodes\");\r\n        return false;\r\n    }\r\n\r\n    let structure = [start];\r\n    let exploredNodes = { [start.id]: true }; // Use bracket notation for dynamic keys\r\n    \r\n    while (structure.length) {\r\n        let currentNode = name === \"BFS\" ? structure.shift() : structure.pop();\r\n        \r\n        // Validate current node\r\n        if (!currentNode || currentNode.row === undefined || currentNode.col === undefined) {\r\n            continue;\r\n        }\r\n\r\n        nodesToAnimate.push(currentNode);\r\n        currentNode.status = \"visited\";\r\n\r\n        // Ending condition\r\n        if (currentNode.id === target.id) return \"success!\";\r\n\r\n        // Get and process neighbors\r\n        let currentNeighbors = getNeighbors(currentNode, grid, name);\r\n        currentNeighbors.forEach(neighbor => {\r\n            if (!neighbor || !neighbor.id) return; // Skip invalid neighbors\r\n            \r\n            if (!exploredNodes[neighbor.id]) {\r\n                if (name === \"BFS\") exploredNodes[neighbor.id] = true;\r\n                \r\n                if (neighbor.id !== start.id) {\r\n                    neighbor.previousNode = currentNode;\r\n                }\r\n                \r\n                // Only push valid neighbors that are within grid bounds\r\n                if (neighbor.row >= 0 && \r\n                    neighbor.row < grid.length && \r\n                    neighbor.col >= 0 && \r\n                    neighbor.col < grid[0].length) {\r\n                    structure.push(neighbor);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction getNeighbors(node, grid, name) {\r\n    const neighbors = [];\r\n    if (!node || !grid) return neighbors;\r\n\r\n    const {col, row} = node;\r\n    \r\n    // Check grid boundaries safely\r\n    if (row > 0) {\r\n        addNeighbor(grid[row - 1][col], neighbors, name);\r\n    }\r\n    if (row < grid.length - 1) {\r\n        addNeighbor(grid[row + 1][col], neighbors, name);\r\n    }\r\n    if (col > 0) {\r\n        addNeighbor(grid[row][col - 1], neighbors, name);\r\n    }\r\n    if (col < grid[0].length - 1) {\r\n        addNeighbor(grid[row][col + 1], neighbors, name);\r\n    }\r\n\r\n    // Fixed typo: stutus → status\r\n    return neighbors.filter(neighbor => \r\n        neighbor && neighbor.status !== \"visited\" && neighbor.status !== \"wall\"\r\n    );\r\n}\r\n\r\nfunction addNeighbor(neighbor, neighbors, name) {\r\n    if (!neighbor) return;\r\n    \r\n    if (name === \"BFS\") {\r\n        neighbors.push(neighbor);\r\n    } else {\r\n        neighbors.unshift(neighbor);\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}