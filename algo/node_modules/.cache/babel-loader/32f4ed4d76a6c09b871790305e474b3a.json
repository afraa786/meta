{"ast":null,"code":"export function nQueensAlgorithm(grid, size = 8) {\n  const boardSize = Math.min(size, grid.length, grid[0].length);\n  const queens = [];\n  const animations = []; // Local animation storage\n  // Reset grid statuses\n\n  for (let row = 0; row < boardSize; row++) {\n    for (let col = 0; col < boardSize; col++) {\n      if (grid[row][col].status !== \"wall\") {\n        grid[row][col].status = \"unvisited\";\n      }\n    }\n  }\n\n  function isSafe(row, col) {\n    if (grid[row][col].status === \"wall\") return false;\n\n    for (const [qRow, qCol] of queens) {\n      if (qCol === col || qRow - qCol === row - col || qRow + qCol === row + col) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function solve(row = 0) {\n    if (row === boardSize) return true;\n\n    for (let col = 0; col < boardSize; col++) {\n      if (isSafe(row, col)) {\n        queens.push([row, col]);\n        const node = grid[row][col];\n        node.status = \"queen\";\n        animations.push({\n          node: { ...node\n          },\n          type: \"queen\"\n        });\n        if (solve(row + 1)) return true; // Backtrack\n\n        queens.pop();\n        node.status = \"visited\";\n        animations.push({\n          node: { ...node\n          },\n          type: \"visited\"\n        });\n      }\n    }\n\n    return false;\n  }\n\n  solve();\n  return {\n    success: queens.length === boardSize,\n    animations\n  };\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/nQueens.js"],"names":["nQueensAlgorithm","grid","size","boardSize","Math","min","length","queens","animations","row","col","status","isSafe","qRow","qCol","solve","push","node","type","pop","success"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAI,GAAG,CAAvC,EAA0C;AAC/C,QAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,CAASH,IAAT,EAAeD,IAAI,CAACK,MAApB,EAA4BL,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAApC,CAAlB;AACA,QAAMC,MAAM,GAAG,EAAf;AACA,QAAMC,UAAU,GAAG,EAAnB,CAH+C,CAGxB;AAEvB;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGN,SAAxB,EAAmCM,GAAG,EAAtC,EAA0C;AACxC,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGP,SAAxB,EAAmCO,GAAG,EAAtC,EAA0C;AACxC,UAAIT,IAAI,CAACQ,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC;AACpCV,QAAAA,IAAI,CAACQ,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,GAAwB,WAAxB;AACD;AACF;AACF;;AAED,WAASC,MAAT,CAAgBH,GAAhB,EAAqBC,GAArB,EAA0B;AACxB,QAAIT,IAAI,CAACQ,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC,OAAO,KAAP;;AAEtC,SAAK,MAAM,CAACE,IAAD,EAAOC,IAAP,CAAX,IAA2BP,MAA3B,EAAmC;AACjC,UAAIO,IAAI,KAAKJ,GAAT,IAAgBG,IAAI,GAAGC,IAAP,KAAgBL,GAAG,GAAGC,GAAtC,IAA6CG,IAAI,GAAGC,IAAP,KAAgBL,GAAG,GAAGC,GAAvE,EAA4E;AAC1E,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAED,WAASK,KAAT,CAAeN,GAAG,GAAG,CAArB,EAAwB;AACtB,QAAIA,GAAG,KAAKN,SAAZ,EAAuB,OAAO,IAAP;;AAEvB,SAAK,IAAIO,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGP,SAAxB,EAAmCO,GAAG,EAAtC,EAA0C;AACxC,UAAIE,MAAM,CAACH,GAAD,EAAMC,GAAN,CAAV,EAAsB;AACpBH,QAAAA,MAAM,CAACS,IAAP,CAAY,CAACP,GAAD,EAAMC,GAAN,CAAZ;AACA,cAAMO,IAAI,GAAGhB,IAAI,CAACQ,GAAD,CAAJ,CAAUC,GAAV,CAAb;AACAO,QAAAA,IAAI,CAACN,MAAL,GAAc,OAAd;AACAH,QAAAA,UAAU,CAACQ,IAAX,CAAgB;AACdC,UAAAA,IAAI,EAAE,EAAC,GAAGA;AAAJ,WADQ;AAEdC,UAAAA,IAAI,EAAE;AAFQ,SAAhB;AAKA,YAAIH,KAAK,CAACN,GAAG,GAAG,CAAP,CAAT,EAAoB,OAAO,IAAP,CATA,CAWpB;;AACAF,QAAAA,MAAM,CAACY,GAAP;AACAF,QAAAA,IAAI,CAACN,MAAL,GAAc,SAAd;AACAH,QAAAA,UAAU,CAACQ,IAAX,CAAgB;AACdC,UAAAA,IAAI,EAAE,EAAC,GAAGA;AAAJ,WADQ;AAEdC,UAAAA,IAAI,EAAE;AAFQ,SAAhB;AAID;AACF;;AACD,WAAO,KAAP;AACD;;AAEDH,EAAAA,KAAK;AACL,SAAO;AAAEK,IAAAA,OAAO,EAAEb,MAAM,CAACD,MAAP,KAAkBH,SAA7B;AAAwCK,IAAAA;AAAxC,GAAP;AACD","sourcesContent":["export function nQueensAlgorithm(grid, size = 8) {\r\n  const boardSize = Math.min(size, grid.length, grid[0].length);\r\n  const queens = [];\r\n  const animations = []; // Local animation storage\r\n\r\n  // Reset grid statuses\r\n  for (let row = 0; row < boardSize; row++) {\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (grid[row][col].status !== \"wall\") {\r\n        grid[row][col].status = \"unvisited\";\r\n      }\r\n    }\r\n  }\r\n\r\n  function isSafe(row, col) {\r\n    if (grid[row][col].status === \"wall\") return false;\r\n    \r\n    for (const [qRow, qCol] of queens) {\r\n      if (qCol === col || qRow - qCol === row - col || qRow + qCol === row + col) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function solve(row = 0) {\r\n    if (row === boardSize) return true;\r\n\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (isSafe(row, col)) {\r\n        queens.push([row, col]);\r\n        const node = grid[row][col];\r\n        node.status = \"queen\";\r\n        animations.push({\r\n          node: {...node},\r\n          type: \"queen\"\r\n        });\r\n        \r\n        if (solve(row + 1)) return true;\r\n\r\n        // Backtrack\r\n        queens.pop();\r\n        node.status = \"visited\";\r\n        animations.push({\r\n          node: {...node},\r\n          type: \"visited\"\r\n        });\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  solve();\r\n  return { success: queens.length === boardSize, animations };\r\n}"]},"metadata":{},"sourceType":"module"}