{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"C:\\\\Users\\\\Afraa\\\\Documents\\\\3D-Pathfinding-Visualizer\\\\src\\\\components\\\\Grid.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useRef, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\nimport img from './floor_texture.jpg';\nimport { tweenToColor, getNodesInShortestPathOrder } from './algorithms/helpers';\nimport TWEEN from '@tweenjs/tween.js';\nimport { weightedSearchAlgorithm } from \"./algorithms/weightedSearchAlgorithm.js\";\nimport { unweightedSearchAlgorithm } from \"./algorithms/unweightedSearchAlgorithm.js\";\nimport { randomMaze, recursiveDivisionMaze } from './algorithms/mazeAlgorithms';\nimport { nQueensAlgorithm } from './algorithms/nQueens.js';\nimport { nQueensInteractive } from './algorithms/nQueensInteractive.js';\nimport { useThree } from 'react-three-fiber';\nimport * as tf from '@tensorflow/tfjs';\nimport { math } from '@tensorflow/tfjs';\n\nfunction Grid(props) {\n  _s();\n\n  const [animationQueue, setAnimationQueue] = useState([]);\n  const [pathQueue, setPathQueue] = useState([]);\n  const [queens, setQueens] = useState([]);\n\n  function handleCellClick(row, col) {\n    let nodesToAnimate = [];\n\n    if (selectedAlgorithm.algorithm === \"nQueens\" && nQueensInteractive) {\n      if (terrain.grid[row][col].status === \"queen\") {\n        nQueensInteractive.removeQueen(row, col);\n      } else {\n        const success = nQueensInteractive.placeQueen(row, col);\n\n        if (!success) {\n          // Show error/conflict\n          const tempNode = { ...terrain.grid[row][col]\n          };\n          tempNode.status = \"conflict\";\n          nodesToAnimate.push(tempNode);\n        }\n      }\n\n      animateAlgorithm(nodesToAnimate, [], algorithmSpeed);\n      return;\n    } // ðŸ‘‡ Your original logic for handleCellClick (for non-nQueens algorithms)\n\n\n    if (selectedAlgorithm.algorithm !== \"nQueens\") return;\n    const isQueen = queens.some(q => q.row === row && q.col === col);\n\n    if (isQueen) {\n      setQueens(queens.filter(q => !(q.row === row && q.col === col)));\n      terrain.grid[row][col].status = \"unvisited\";\n    } else {\n      const isValid = !queens.some(q => q.col === col || q.row - q.col === row - col || q.row + q.col === row + col);\n\n      if (isValid) {\n        setQueens([...queens, {\n          row,\n          col\n        }]);\n        terrain.grid[row][col].status = \"queen\";\n      } else {\n        const node = terrain.grid[row][col];\n        tweenToColor(node, groundGeometry, [{\n          r: 1,\n          g: 0,\n          b: 0\n        }], 150);\n        setTimeout(() => {\n          tweenToColor(node, groundGeometry, [props.worldProperties.colors.default], 150);\n        }, 300);\n        return;\n      }\n    }\n\n    visualizeAttackPaths();\n  }\n\n  function visualizeAttackPaths() {\n    // Clear previous attack paths\n    terrain.grid.forEach(row => row.forEach(node => {\n      if (node.status === \"attack\") node.status = \"unvisited\";\n    })); // Show attack paths for all queens\n\n    queens.forEach(({\n      row,\n      col\n    }) => {\n      // Highlight row\n      for (let c = 0; c < terrain.grid[0].length; c++) {\n        if (c !== col) terrain.grid[row][c].status = \"attack\";\n      } // Highlight column\n\n\n      for (let r = 0; r < terrain.grid.length; r++) {\n        if (r !== row) terrain.grid[r][col].status = \"attack\";\n      } // Highlight diagonals\n\n\n      for (let r = 0; r < terrain.grid.length; r++) {\n        for (let c = 0; c < terrain.grid[0].length; c++) {\n          if (Math.abs(r - row) === Math.abs(c - col) && !(r === row && c === col)) {\n            terrain.grid[r][c].status = \"attack\";\n          }\n        }\n      }\n    });\n  }\n\n  let groundMaterial;\n  let groundMesh;\n  let mouseDownX = 0;\n  let mouseDownY = 0;\n  let previousHoverNodeId;\n  let currentHoverNodeId;\n  let mouseIsUp = true;\n  const [groundGeometry, setGroundGeometry] = useState(new THREE.PlaneGeometry(300, 300, 30, 30));\n  const selectedAlgorithm = props.selectedAlgorithm;\n  const selectedMazeAlgorithm = props.selectedMazeAlgorithm;\n  const runState = props.worldProperties.runState;\n  const trainTheAgent = props.worldProperties.trainAgent;\n  const clearTheWalls = props.worldProperties.clearWalls; //rename this variable\n\n  const clearThePath = props.worldProperties.clearPath; // rename this variable too\n\n  const algorithmSpeed = props.algorithmSpeed;\n  const agentKnowledge = props.agentKnowledge;\n  const applyingSettings = props.applyingSettings;\n  const visualizeThePolicy = props.visualizeOptimalPolicy;\n  const {\n    camera\n  } = useThree();\n  useEffect(() => {\n    if (props.applyingSettings) {\n      resetTerrainConfig();\n    }\n\n    if (props.visualizeOptimalPolicy) {\n      calculateOptimalPolicy();\n      animateOptimalPolicy();\n      props.finishedOptimalPolicy();\n    }\n  }, [applyingSettings, visualizeThePolicy]);\n  useEffect(() => {\n    if (props.agentKnowledge === \"clearMemory\") {\n      terrain.records = [];\n      terrain.q_table = Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)); //clearPath();\n\n      props.agentResetDone();\n    }\n\n    if (props.worldProperties.runState === true) {\n      if (props.selectedAlgorithm.type === \"machine-learning\") {\n        animateQlearning();\n      } else {\n        visualizeAlgorithm();\n      }\n    } else if (props.worldProperties.clearWalls === true) {\n      clearWalls();\n    } else if (props.worldProperties.clearPath === true) {\n      clearPath();\n    } else if (props.worldProperties.trainAgent === true) {\n      qLearning();\n    } else if (props.selectedMazeAlgorithm === \"randomMaze\") {\n      clearPath();\n      let nodesToAnimate = [];\n      randomMaze(terrain.grid, nodesToAnimate, \"wall\");\n      animateMaze(nodesToAnimate, \"wall\", 30);\n    } else if (props.selectedMazeAlgorithm === \"recursiveDivision\") {\n      clearPath();\n      let nodesToAnimate = [];\n      recursiveDivisionMaze(terrain.grid, 2, terrain.grid.length - 3, 2, terrain.grid.length - 3, \"horizontal\", false, nodesToAnimate, \"wall\");\n      animateMaze(nodesToAnimate, \"wall\", 30);\n    }\n  }, [runState, clearTheWalls, clearThePath, selectedMazeAlgorithm, trainTheAgent, agentKnowledge]);\n  const loader = useMemo(() => new THREE.TextureLoader().load(img, function (texture) {\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n    texture.repeat.x = 30;\n    texture.repeat.y = 30;\n    groundMaterial = new THREE.MeshLambertMaterial({\n      map: texture,\n      side: THREE.FrontSide,\n      vertexColors: THREE.FaceColors\n    });\n    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);\n    groundMesh.receiveShadow = true;\n  }), [img]);\n  groundMaterial = new THREE.MeshLambertMaterial({\n    map: loader,\n    side: THREE.FrontSide,\n    vertexColors: THREE.FaceColors\n  });\n  const mesh = useRef(null);\n  const [terrain, setTerrain] = useState({\n    grid: initializeGrid(),\n    states: initStates(),\n    q_table: Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)),\n    records: [],\n    optimalPolicy: [],\n    actions: {\n      \"left\": [0, -1],\n      \"down\": [1, 0],\n      \"right\": [0, 1],\n      \"up\": [-1, 0]\n    },\n    //visits: Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)),\n    discountFactor: 0.8,\n    alpha: 0.1,\n    start: [props.settingsConfig.startRow, props.settingsConfig.startCol],\n    finish: [props.settingsConfig.finishRow, props.settingsConfig.finishCol]\n  });\n\n  function initializeGrid() {\n    let tempGrid = [];\n\n    for (let i = 0; i < 30; i++) {\n      let currentRow = [];\n\n      for (let j = 0; j < 30; j++) {\n        let node = createNode(i, j);\n        currentRow.push(node);\n      }\n\n      tempGrid.push(currentRow);\n    }\n    /*var vertices = new Float32Array(5400).fill(0);\r\n      groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute( vertices,3) );\r\n    vertices[0] = 0\r\n    vertices[1]= 1\r\n    vertices[2]= 0\r\n      \r\n      console.log(groundGeometry.getAttribute('color'))\r\n    const tween1 = new TWEEN.Tween(groundGeometry.getAttribute('color'))\r\n                    .to(new THREE.Float32BufferAttribute( vertices,2) ,9000)\r\n      tween1.start()\r\n      tween1.onUpdate(function (object: THREE.BufferAttribute | THREE.InterleavedBufferAttribute, elapsed: number){\r\n      groundGeometry.setAttribute('color',object)\r\n    })\r\n    \r\n    \n    //console.log(vertices)\r\n    groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute( vertices,2) );*/\n    //setState(tempStateGrid)\n\n\n    renderLoop();\n    return tempGrid;\n  }\n\n  function visualizeAlgorithm() {\n    console.log(\"Visualizing algorithm:\", selectedAlgorithm.algorithm);\n    clearPath();\n    let animations = [];\n    let pathNodes = [];\n    const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\n    const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\n\n    if (selectedAlgorithm.type === \"weighted\") {\n      const result = weightedSearchAlgorithm(terrain.grid, startNode, finishNode, animations, selectedAlgorithm.algorithm, selectedAlgorithm.heuristic);\n\n      if (result === \"success!\") {\n        pathNodes = getNodesInShortestPathOrder(finishNode);\n      }\n    } else if (selectedAlgorithm.type === \"unweighted\") {\n      const result = unweightedSearchAlgorithm(terrain.grid, startNode, finishNode, animations, selectedAlgorithm.algorithm);\n\n      if (result === \"success!\") {\n        pathNodes = getNodesInShortestPathOrder(finishNode);\n      }\n    } else if (selectedAlgorithm.algorithm === \"nQueens\") {\n      const {\n        animations: queenAnimations\n      } = nQueensAlgorithm(terrain.grid);\n      animations = queenAnimations;\n    }\n\n    animateAlgorithm(animations, pathNodes, algorithmSpeed);\n    props.updateRunState(false);\n  }\n\n  function createNode(row, col) {\n    let status = \"default\";\n    let faces = {};\n    let faceIndex = row * 2 * props.worldProperties.cols + col * 2;\n    faces[1] = groundGeometry.faces[faceIndex];\n    faceIndex = faceIndex % 2 === 0 ? faceIndex + 1 : faceIndex - 1;\n    faces[2] = groundGeometry.faces[faceIndex];\n\n    if (row === props.worldProperties.start.row && col === props.worldProperties.start.col) {\n      status = \"start\";\n    } else if (row === props.worldProperties.finish.row && col === props.worldProperties.finish.col) {\n      status = \"finish\";\n    }\n\n    let node = {\n      id: row * props.worldProperties.cols + col,\n      row: row,\n      col: col,\n      faces: faces,\n      status: status,\n      distance: Infinity,\n      totalDistance: Infinity,\n      heuristicDistance: null,\n      direction: null,\n      weight: 0,\n      qValue: 0,\n      reward: 0,\n      visits: 0,\n      onceSpecial: false,\n      previousNode: null\n    };\n\n    if (status === \"start\") {\n      node.onceSpecial = true;\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.start]);\n    } else if (status === \"finish\") {\n      node.reward = 100;\n      node.onceSpecial = true;\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.finish]);\n    }\n\n    return node;\n  }\n\n  function initStates() {\n    let tempStateGrid = [];\n\n    for (let row = 0; row < props.worldProperties.rows; row++) {\n      for (let col = 0; col < props.worldProperties.cols; col++) {\n        tempStateGrid.push([row, col]);\n      }\n    } //console.log(tempStateGrid)\n\n\n    return tempStateGrid;\n  }\n  /*function initializeVisits(){\r\n    let visits = {}\r\n    let tempStates = initStates()\r\n    for(let row = 0; row < tempStates.length; row++){\r\n      for(let col = 0; col < tempStates[0].length; col++){\r\n        let state = tempStates[row][col]\r\n        visits[state] = 0;\r\n      }\r\n    }\r\n    return visits;\r\n  }*/\n\n\n  function renderLoop() {\n    window.requestAnimationFrame(renderLoop); //if(props.resetStatus){\n\n    hoverLoop(); // }\n\n    TWEEN.update();\n  }\n\n  function hoverLoop() {\n    if (mouseIsUp || currentHoverNodeId === previousHoverNodeId) {\n      return;\n    } else {\n      previousHoverNodeId = currentHoverNodeId;\n      let nodeRow = Math.floor(currentHoverNodeId / props.worldProperties.rows);\n      let nodeCol = currentHoverNodeId % props.worldProperties.cols;\n\n      if (nodeRow === props.worldProperties.start.row && nodeCol === props.worldProperties.start.col || nodeRow === props.worldProperties.finish.row && nodeCol === props.worldProperties.finish.col) {\n        return;\n      } else if (terrain.grid[nodeRow][nodeCol].status === \"wall\") {\n        terrain.grid[nodeRow][nodeCol].status = \"default\";\n        terrain.grid[nodeRow][nodeCol].reward = 0;\n        terrain.grid[nodeRow][nodeCol].visits = 0;\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.default]);\n      } else {\n        terrain.grid[nodeRow][nodeCol].status = \"wall\";\n        terrain.grid[nodeRow][nodeCol].visits = -1;\n        terrain.grid[nodeRow][nodeCol].reward = -100;\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n      }\n    } //get coordinates of node i just clicked on\n\n  }\n\n  function mouseUpHandler(event) {\n    if (mouseDownX !== event.clientX || mouseDownY !== event.clientY) {\n      return;\n    } else {\n      let nodeId = findNodeId(event.faceIndex);\n\n      if (nodeId.nodeRow === props.worldProperties.start.row && nodeId.nodeCol === props.worldProperties.start.col || nodeId.nodeRow === props.worldProperties.finish.row && nodeId.nodeCol === props.worldProperties.finish.col) {\n        return;\n      } else if (terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status === \"wall\") {\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = 0;\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"default\";\n        tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.default]); //console.log(terrain.grid[nodeId.nodeRow][nodeId.nodeCol]);\n      } else {\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = -100;\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"wall\";\n        tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.wall]); //console.log(terrain.grid[nodeId.nodeRow][nodeId.nodeCol]);\n      } //console.log(terrain.grid)\n\n    }\n  }\n\n  function findNodeId(faceIndex) {\n    let linearIndex = Math.floor(faceIndex / 2);\n    return {\n      nodeRow: Math.floor(linearIndex / props.worldProperties.rows),\n      nodeCol: linearIndex % props.worldProperties.cols\n    };\n  }\n\n  function mouseDownHandler(event) {\n    mouseDownX = event.clientX; //set X and Y mouse coordinates when mouseDown\n\n    mouseDownY = event.clientY;\n  }\n\n  function visualizeAlgorithm() {\n    console.log(\"Visualizing algorithm:\", selectedAlgorithm.algorithm);\n    clearPath();\n    let nodesToAnimate = []; // Define nodesToAnimate here\n\n    let result;\n    const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\n    const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\n\n    if (selectedAlgorithm.type === \"weighted\") {\n      result = weightedSearchAlgorithm(terrain.grid, startNode, finishNode, nodesToAnimate, selectedAlgorithm.algorithm, selectedAlgorithm.heuristic);\n    } else if (selectedAlgorithm.type === \"unweighted\") {\n      result = unweightedSearchAlgorithm(terrain.grid, startNode, finishNode, nodesToAnimate, selectedAlgorithm.algorithm);\n    } else if (selectedAlgorithm.algorithm === \"nQueens\") {\n      nodesToAnimate = nQueensAlgorithm(terrain.grid, nodesToAnimate, props.worldProperties.gridSize || 8);\n      animateAlgorithm(nodesToAnimate, [], algorithmSpeed);\n      props.updateRunState(false);\n      return;\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateAlgorithm(nodesToAnimate, nodesInShortestPathOrder, algorithmSpeed);\n  } // In your Grid component\n\n\n  const [nQueensInteractive, setNQueensInteractive] = useState(null);\n  useEffect(() => {\n    if (selectedAlgorithm.algorithm === \"nQueens\") {\n      setNQueensInteractive(nQueensInteractive(terrain.grid, []));\n    }\n  }, [selectedAlgorithm]);\n\n  function handleCellClick(row, col) {\n    if (selectedAlgorithm.algorithm === \"nQueens\" && nQueensInteractive) {\n      const nodesToAnimate = []; // âœ… Declare it here\n\n      if (terrain.grid[row][col].status === \"queen\") {\n        nQueensInteractive.removeQueen(row, col);\n      } else {\n        const success = nQueensInteractive.placeQueen(row, col);\n\n        if (!success) {\n          // Show error/conflict\n          const tempNode = { ...terrain.grid[row][col]\n          };\n          tempNode.status = \"conflict\";\n          nodesToAnimate.push({\n            node: tempNode,\n            type: \"conflict\"\n          });\n        }\n      }\n\n      animateAlgorithm(nodesToAnimate, [], algorithmSpeed); // âœ… Now it's defined\n    }\n  } // Modify your mesh click handler to use handleCellClick\n\n\n  function animateAlgorithm(visitedNodes, pathNodes, speed) {\n    // Clear previous animations\n    TWEEN.removeAll(); // Animate visited nodes\n\n    visitedNodes.forEach((item, i) => {\n      setTimeout(() => {\n        if (!item.node) return;\n        let color;\n\n        if (selectedAlgorithm.algorithm === \"nQueens\") {\n          color = item.type === \"queen\" ? {\n            r: 1,\n            g: 0,\n            b: 1\n          } // Purple for queens\n          : {\n            r: 0.8,\n            g: 0.8,\n            b: 0.8\n          }; // Gray for visited\n        } else {\n          color = {\n            r: 1.0,\n            g: 0.321,\n            b: 0.784\n          }; // Pink for pathfinding\n        }\n\n        tweenToColor(item.node, groundGeometry, [color], 300, {\n          position: false\n        });\n      }, speed * i);\n    }); // Animate path if exists\n\n    pathNodes.forEach((node, i) => {\n      setTimeout(() => {\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.path], 300, {\n          position: false\n        });\n      }, speed * (visitedNodes.length + i * 5));\n    });\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder, timerDelay) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.path], undefined, {\n          position: false\n        });\n\n        if (i === nodesInShortestPathOrder.length - 1) {}\n      }, timerDelay * i);\n    }\n\n    props.updateRunState(false); //console.log(terrain.grid[5][5]);\n  }\n\n  function animateQlearning() {\n    clearPath();\n    let minimum = -10;\n    let maximum = 100;\n\n    for (let i = 0; i < terrain.records.length; i++) {\n      //let record = terrain.records[i]\n      //if(i > 1300){return;}\n      for (let row = 0; row < 30; row++) {\n        for (let col = 0; col < 30; col++) {\n          const node = terrain.grid[row][col];\n\n          if (terrain.records[i][row][col] === 0 || node.status === \"wall\" || node.status === \"start\" || node.status === \"finish\") {\n            continue;\n          }\n\n          let ratio = 2 * (terrain.records[i][row][col] - minimum) / (maximum - minimum);\n          let blue = Number(Math.max(0, 255 * (1 - ratio)));\n          let red = Number(Math.max(0, 255 * (ratio - 1)));\n          let green = 255 - blue - red;\n          red /= 255;\n          green /= 255;\n          blue /= 255;\n          setTimeout(() => {\n            tweenToColor(node, groundGeometry, [{\n              r: red,\n              g: green,\n              b: blue\n            }], 5, {\n              position: false\n            }); //if (row === 30 - 1) {}\n          }, 1000);\n        }\n      }\n    }\n\n    props.updateRunState(false);\n  }\n\n  function animateOptimalPolicy() {\n    for (let i = 2; i < terrain.optimalPolicy.length; i++) {\n      let headRow = terrain.optimalPolicy[i][0];\n      let headCol = terrain.optimalPolicy[i][1]; //let torsoRow = terrain.optimalPolicy[i-1][0];\n      //let torsoCol = terrain.optimalPolicy[i-1][1];\n\n      let tailRow = terrain.optimalPolicy[i - 1][0];\n      let tailCol = terrain.optimalPolicy[i - 1][1];\n      const head = terrain.grid[headRow][headCol]; //const torso = terrain.grid[torsoRow][torsoCol];\n\n      const tail = terrain.grid[tailRow][tailCol];\n\n      if (head.status === 'start' || tail.status == 'start') {\n        continue;\n      }\n\n      setTimeout(() => {\n        if (head.status === 'finish') return; //terrain.grid[row][col].status = visited;\n        //setTimeout(() => {\n        //tweenToColor(tail, groundGeometry, [props.worldProperties.colors.path], undefined,{position: false});\n        //}, i*props.algorithmSpeed);\n\n        tweenToColor(tail, groundGeometry, [props.worldProperties.colors.path], undefined, {\n          position: false\n        });\n        tweenToColor(head, groundGeometry, [{\n          r: 0,\n          g: 0,\n          b: 0\n        }], undefined, {\n          position: false\n        }); //tweenToColor(torso, groundGeometry, [{r: 0, g: 0, b: 0}], undefined,{position: false});\n      }, 5 * i * props.algorithmSpeed);\n    }\n  }\n\n  function qLearning() {\n    //reset records\n    if (props.settingsConfig.epochs > 0) {\n      terrain.records = [];\n    } //let i = 0;\n    //while(terrain.records.length < 1000){\n\n\n    for (let i = 0; i < props.settingsConfig.epochs; i++) {\n      //if(terrain.records.length > 1300){break;}\n      if (i > 0.75 * props.settingsConfig.epochs) {\n        let y = props.settingsConfig.startRow;\n        let x = props.settingsConfig.startCol;\n        var currentState = [y, x];\n      } else {\n        var currentState = terrain.states[Math.floor(Math.random() * terrain.states.length)];\n      }\n\n      var steps = 0;\n\n      while (!(currentState[0] === props.settingsConfig.finishRow && currentState[1] === props.settingsConfig.finishCol) && terrain.grid[currentState[0]][currentState[1]].status !== \"wall\" && steps < 1000) {\n        //setTimeout(() => {\n        //tweenToColor(terrain.grid[14][14],groundGeometry,[{ r: 1, g: 0.64, b: 0.0}]);\n        //}, props.algorithmSpeed);\n        //let action = chooseAction(currentState, Math.abs(1- (i/props.settingsConfig.epochs)))\n        var curiosity = props.settingsConfig.agentCuriosity;\n\n        if (i > 0.75 * props.settingsConfig.epochs) {\n          curiosity = 0.4;\n        }\n\n        let action = chooseAction(currentState, curiosity);\n        let action_dy = terrain.actions[action][0];\n        let action_dx = terrain.actions[action][1];\n        let nextState = [action_dy + currentState[0], action_dx + currentState[1]];\n        let currentQValue = terrain.q_table[currentState[0]][currentState[1]]; //let maximum_action = chooseAction(currentState, 0)//might need to be nextstate\n        //action_dy = terrain.actions[maximum_action][0]\n        //action_dx = terrain.actions[maximum_action][1]\n\n        let maxState = [action_dy + currentState[0], action_dx + currentState[1]];\n        let maxQValue = terrain.q_table[maxState[0]][maxState[1]];\n        let temporal_difference = terrain.grid[nextState[0]][nextState[1]].reward + terrain.discountFactor * (maxQValue - currentQValue); //let learning_rate = 1 / (1 + terrain.grid[currentState[0]][currentState[1]].visits)\n\n        let q_value = currentQValue + props.settingsConfig.learningRate * temporal_difference;\n        terrain.q_table[currentState[0]][currentState[1]] = parseFloat(q_value.toFixed(2));\n        terrain.grid[currentState[0]][currentState[1]].visits += 1;\n        currentState = nextState;\n        steps++;\n      } //i++;\n\n\n      terrain.records.push(getRecord());\n    }\n\n    props.stopTraining(); //console.log(props.settingsConfig.epochs);\n\n    console.log(terrain.records); //console.log(terrain.grid)\n  }\n\n  function chooseAction(currentState, e_greedy) {\n    var rwc = require(\"random-weighted-choice\");\n\n    let actionOptions = [{\n      weight: e_greedy * 10,\n      id: \"true\"\n    }, {\n      weight: 10 * (1 - e_greedy),\n      id: \"false\"\n    }];\n    let chosenOption = rwc(actionOptions);\n    let takingRandomAction = chosenOption === \"true\"; //true or false;\n\n    let actions = [\"left\", \"down\", \"right\", \"up\"];\n\n    if (takingRandomAction) {\n      //console.log(\"Taking random action\");\n      //let random_index = random.randint(0,len(actions) - 1)\n      while (true) {\n        let randomIndex = Math.floor(Math.random() * actions.length);\n        let selectedAction = actions[randomIndex];\n        let actionChange = terrain.actions[selectedAction];\n\n        if (isValidState([actionChange[0] + currentState[0], actionChange[1] + currentState[1]])) {\n          //console.log(\"When action is random action is: \" + selectedAction)\n          return selectedAction;\n        }\n      }\n    } else {\n      //console.log(\"Taking greedy action\");\n      //let policyCandidates = new WeakMap();\n      let policyCandidates = {};\n\n      for (let action in terrain.actions) {\n        let nextState = [terrain.actions[action][0] + currentState[0], terrain.actions[action][1] + currentState[1]]; //console.log(nextState)\n\n        if (isValidState(nextState)) {\n          //console.log(terrain.q_table);\n          policyCandidates[nextState] = terrain.q_table[nextState[0]][nextState[1]]; //policyCandidates.set(nextState,terrain.q_table[nextState[1]][nextState[0]]);\n        }\n      } //let maxState = max(policy_candidates, key=policy_candidates.get)\n\n\n      let maxQValue = Number(Object.keys(policyCandidates).reduce((a, v) => Math.max(a, policyCandidates[v]), -Infinity));\n      let maxState = Object.keys(policyCandidates).filter(v => policyCandidates[v] === maxQValue); //let maxQValue = policy_candidates[maxState]\n\n      let listOfMax = [];\n\n      for (let maxCandidate in policyCandidates) {\n        if (policyCandidates[maxCandidate] === maxQValue) {\n          let tempVals = maxCandidate.split(\",\").map(Number);\n          listOfMax.push(tempVals);\n        }\n      }\n\n      let randomIndex = Math.floor(Math.random() * listOfMax.length);\n      maxState = listOfMax[randomIndex]; //console.log(listOfMax)\n      //Now we can use the max_state(state with the maximum q value to find the actioned perfomed to get there)\n\n      let action_dy = maxState[0] - currentState[0];\n      let action_dx = maxState[1] - currentState[1];\n\n      for (let action in terrain.actions) {\n        if (terrain.actions[action][0] === action_dy && terrain.actions[action][1] === action_dx) {\n          return action;\n        }\n      }\n    }\n  }\n\n  function isValidState(nextState) {\n    //console.log(nextState)\n    if (nextState[0] < 0 || nextState[0] >= props.worldProperties.rows || nextState[1] < 0 || nextState[1] >= props.worldProperties.cols) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getRecord() {\n    let record = Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0));\n\n    for (let i = 0; i < terrain.states.length; i++) {\n      let state = terrain.states[i];\n      record[state[0]][state[1]] = terrain.q_table[state[0]][state[1]];\n    } //console.log(record)\n\n\n    return record;\n  }\n\n  function resetTerrainConfig() {\n    for (let row = 0; row < 30; row++) {\n      for (let col = 0; col < 30; col++) {\n        if (terrain.grid[row][col].status === \"wall\") {\n          continue;\n        }\n\n        if (row === props.settingsConfig.startRow && col === props.settingsConfig.startCol) {\n          terrain.grid[row][col].status = \"start\";\n          terrain.grid[row][col].onceSpecial = true;\n        } else if (row === props.settingsConfig.finishRow && col === props.settingsConfig.finishCol) {\n          terrain.grid[row][col].status = \"finish\";\n          terrain.grid[row][col].reward = 100;\n          terrain.grid[row][col].onceSpecial = true;\n        } else {\n          terrain.grid[row][col].status = \"default\";\n          terrain.grid[row][col].reward = 0;\n\n          if (terrain.grid[row][col].onceSpecial) {\n            tweenToColor(terrain.grid[row][col], groundGeometry, [props.worldProperties.colors.default]);\n          }\n        }\n      }\n    } //console.log(terrain.records)\n\n\n    props.finishApplyingSettings();\n  }\n\n  function calculateOptimalPolicy() {\n    let currentState = [props.settingsConfig.startRow, props.settingsConfig.startCol];\n    let policyList = [];\n    policyList.push(currentState);\n\n    while (!(currentState[0] === props.settingsConfig.finishRow && currentState[1] === props.settingsConfig.finishCol) && terrain.grid[currentState[0]][currentState[1]].status !== \"wall\") {\n      let maxAction = chooseAction(currentState, props.policyCuriosity);\n      let action_dy = terrain.actions[maxAction][0];\n      let action_dx = terrain.actions[maxAction][1];\n      let nextState = [action_dy + currentState[0], action_dx + currentState[1]];\n      policyList.push(nextState);\n      currentState = nextState; //console.log(maxAction);\n      //console.log(action_dy);\n    }\n\n    terrain.optimalPolicy = policyList;\n  }\n\n  function clearWalls() {\n    for (let i = 0; i < props.worldProperties.rows; i++) {\n      for (let j = 0; j < props.worldProperties.cols; j++) {\n        if (terrain.grid[i][j].status === \"wall\" || terrain.q_table[i][j] < 0) {\n          terrain.grid[i][j].status = \"default\";\n          terrain.grid[i][j].reward = 0;\n          tweenToColor(terrain.grid[i][j], groundGeometry, [props.worldProperties.colors.default]);\n        }\n      }\n    }\n\n    props.stopClearWalls();\n  }\n\n  function clearPath() {\n    TWEEN.removeAll();\n\n    for (let i = 0; i < props.worldProperties.rows; i++) {\n      for (let j = 0; j < props.worldProperties.cols; j++) {\n        if (i === props.worldProperties.start.row && j === props.worldProperties.start.col) {\n          terrain.grid[i][j].status = \"start\";\n          terrain.grid[i][j].visits = -1;\n        }\n\n        if (i === props.worldProperties.finish.row && j === props.worldProperties.finish.col) {\n          terrain.grid[i][j].status = \"finish\";\n        }\n\n        if (terrain.grid[i][j].status === \"visited\" || terrain.grid[i][j].visits > 0) {\n          terrain.grid[i][j].status = \"default\";\n          tweenToColor(terrain.grid[i][j], groundGeometry, [props.worldProperties.colors.default]);\n        }\n\n        terrain.grid[i][j].distance = Infinity;\n        terrain.grid[i][j].totalDistance = Infinity;\n        terrain.grid[i][j].heuristicDistance = null;\n        terrain.grid[i][j].direction = null;\n        terrain.grid[i][j].previousNode = null;\n      }\n    }\n\n    props.stopClearPath();\n  }\n\n  function animateMaze(nodesToAnimate, type, timerDelay) {\n    clearWalls();\n\n    for (let i = 0; i < nodesToAnimate.length; i++) {\n      let nodeRow = nodesToAnimate[i].row;\n      let nodeCol = nodesToAnimate[i].col;\n      setTimeout(() => {\n        //const node = nodesToAnimate[i];\n        // node.status = type;\n        terrain.grid[nodeRow][nodeCol].status = \"wall\";\n        terrain.grid[nodeRow][nodeCol].reward = -100;\n        terrain.grid[nodeRow][nodeCol].visits = -1;\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n      }, timerDelay * i);\n      props.stopMazeSelection();\n    }\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"mesh\", {\n    ref: mesh,\n    position: [0, 0, 0],\n    children: [/*#__PURE__*/_jsxDEV(\"gridHelper\", {\n      args: [300, props.gridDimensions, 0x5c78bd, 0x5c78bd]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 904,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"mesh\", {\n      rotation: [-Math.PI / 2, 0, 0],\n      position: [0, -0.1, 0],\n      receiveShadow: true,\n      onPointerDown: e => {\n        mouseIsUp = false;\n        mouseDownHandler(e);\n      },\n      onPointerUp: e => {\n        if (props.resetStatus === true || mouseIsUp === true) {\n          mouseIsUp = true;\n        }\n\n        mouseUpHandler(e);\n      },\n      onPointerMove: e => {\n        if (mouseIsUp === true || props.resetStatus === false) {\n          return;\n        } else if (mouseIsUp === false) {\n          currentHoverNodeId = Math.floor(e.faceIndex / 2);\n          return;\n        }\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"primitive\", {\n        attach: \"geometry\",\n        object: groundGeometry\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 929,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"primitive\", {\n        attach: \"material\",\n        object: groundMaterial\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 930,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 905,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"axesHelper\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 932,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 903,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Grid, \"tdrSH/9z64REXarj6MthXS9XXws=\", false, function () {\n  return [useThree];\n});\n\n_c = Grid;\nexport default Grid;\n\nvar _c;\n\n$RefreshReg$(_c, \"Grid\");","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/Grid.js"],"names":["React","useState","useRef","useEffect","useMemo","THREE","img","tweenToColor","getNodesInShortestPathOrder","TWEEN","weightedSearchAlgorithm","unweightedSearchAlgorithm","randomMaze","recursiveDivisionMaze","nQueensAlgorithm","nQueensInteractive","useThree","tf","math","Grid","props","animationQueue","setAnimationQueue","pathQueue","setPathQueue","queens","setQueens","handleCellClick","row","col","nodesToAnimate","selectedAlgorithm","algorithm","terrain","grid","status","removeQueen","success","placeQueen","tempNode","push","animateAlgorithm","algorithmSpeed","isQueen","some","q","filter","isValid","node","groundGeometry","r","g","b","setTimeout","worldProperties","colors","default","visualizeAttackPaths","forEach","c","length","Math","abs","groundMaterial","groundMesh","mouseDownX","mouseDownY","previousHoverNodeId","currentHoverNodeId","mouseIsUp","setGroundGeometry","PlaneGeometry","selectedMazeAlgorithm","runState","trainTheAgent","trainAgent","clearTheWalls","clearWalls","clearThePath","clearPath","agentKnowledge","applyingSettings","visualizeThePolicy","visualizeOptimalPolicy","camera","resetTerrainConfig","calculateOptimalPolicy","animateOptimalPolicy","finishedOptimalPolicy","records","q_table","Array","rows","fill","map","cols","agentResetDone","type","animateQlearning","visualizeAlgorithm","qLearning","animateMaze","loader","TextureLoader","load","texture","wrapS","RepeatWrapping","wrapT","repeat","x","y","MeshLambertMaterial","side","FrontSide","vertexColors","FaceColors","Mesh","receiveShadow","mesh","setTerrain","initializeGrid","states","initStates","optimalPolicy","actions","discountFactor","alpha","start","settingsConfig","startRow","startCol","finish","finishRow","finishCol","tempGrid","i","currentRow","j","createNode","renderLoop","console","log","animations","pathNodes","startNode","finishNode","result","heuristic","queenAnimations","updateRunState","faces","faceIndex","id","distance","Infinity","totalDistance","heuristicDistance","direction","weight","qValue","reward","visits","onceSpecial","previousNode","tempStateGrid","window","requestAnimationFrame","hoverLoop","update","nodeRow","floor","nodeCol","wall","mouseUpHandler","event","clientX","clientY","nodeId","findNodeId","linearIndex","mouseDownHandler","gridSize","nodesInShortestPathOrder","setNQueensInteractive","visitedNodes","speed","removeAll","item","color","position","path","animateShortestPath","timerDelay","undefined","minimum","maximum","ratio","blue","Number","max","red","green","headRow","headCol","tailRow","tailCol","head","tail","epochs","currentState","random","steps","curiosity","agentCuriosity","action","chooseAction","action_dy","action_dx","nextState","currentQValue","maxState","maxQValue","temporal_difference","q_value","learningRate","parseFloat","toFixed","getRecord","stopTraining","e_greedy","rwc","require","actionOptions","chosenOption","takingRandomAction","randomIndex","selectedAction","actionChange","isValidState","policyCandidates","Object","keys","reduce","a","v","listOfMax","maxCandidate","tempVals","split","record","state","finishApplyingSettings","policyList","maxAction","policyCuriosity","stopClearWalls","stopClearPath","stopMazeSelection","gridDimensions","PI","e","resetStatus"],"mappings":"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","sourcesContent":["import React, { useState, useRef, useEffect, useMemo } from 'react'\r\nimport * as THREE from 'three'\r\nimport img from './floor_texture.jpg';\r\nimport { tweenToColor, getNodesInShortestPathOrder } from './algorithms/helpers'\r\nimport TWEEN from '@tweenjs/tween.js';\r\nimport { weightedSearchAlgorithm } from \"./algorithms/weightedSearchAlgorithm.js\";\r\nimport { unweightedSearchAlgorithm } from \"./algorithms/unweightedSearchAlgorithm.js\";\r\nimport { randomMaze, recursiveDivisionMaze } from './algorithms/mazeAlgorithms';\r\nimport { nQueensAlgorithm } from './algorithms/nQueens.js';\r\nimport { nQueensInteractive } from './algorithms/nQueensInteractive.js';\r\nimport { useThree } from 'react-three-fiber';\r\nimport * as tf from '@tensorflow/tfjs';\r\nimport { math } from '@tensorflow/tfjs';\r\n\r\n\r\n\r\n\r\nfunction Grid(props) {\r\nconst [animationQueue, setAnimationQueue] = useState([]);\r\n  const [pathQueue, setPathQueue] = useState([]);\r\n  const [queens, setQueens] = useState([]);\r\n\r\nfunction handleCellClick(row, col) {\r\n  let nodesToAnimate = [];\r\n\r\n  if (selectedAlgorithm.algorithm === \"nQueens\" && nQueensInteractive) {\r\n    if (terrain.grid[row][col].status === \"queen\") {\r\n      nQueensInteractive.removeQueen(row, col);\r\n    } else {\r\n      const success = nQueensInteractive.placeQueen(row, col);\r\n      if (!success) {\r\n        // Show error/conflict\r\n        const tempNode = { ...terrain.grid[row][col] };\r\n        tempNode.status = \"conflict\";\r\n        nodesToAnimate.push(tempNode);\r\n      }\r\n    }\r\n\r\n    animateAlgorithm(nodesToAnimate, [], algorithmSpeed);\r\n    return;\r\n  }\r\n\r\n  // ðŸ‘‡ Your original logic for handleCellClick (for non-nQueens algorithms)\r\n  if (selectedAlgorithm.algorithm !== \"nQueens\") return;\r\n\r\n  const isQueen = queens.some(q => q.row === row && q.col === col);\r\n  \r\n  if (isQueen) {\r\n    setQueens(queens.filter(q => !(q.row === row && q.col === col)));\r\n    terrain.grid[row][col].status = \"unvisited\";\r\n  } else {\r\n    const isValid = !queens.some(q =>\r\n      q.col === col ||\r\n      q.row - q.col === row - col ||\r\n      q.row + q.col === row + col\r\n    );\r\n\r\n    if (isValid) {\r\n      setQueens([...queens, { row, col }]);\r\n      terrain.grid[row][col].status = \"queen\";\r\n    } else {\r\n      const node = terrain.grid[row][col];\r\n      tweenToColor(node, groundGeometry, [{ r: 1, g: 0, b: 0 }], 150);\r\n      setTimeout(() => {\r\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.default], 150);\r\n      }, 300);\r\n      return;\r\n    }\r\n  }\r\n\r\n  visualizeAttackPaths();\r\n}\r\n\r\nfunction visualizeAttackPaths() {\r\n  // Clear previous attack paths\r\n  terrain.grid.forEach(row => row.forEach(node => {\r\n    if (node.status === \"attack\") node.status = \"unvisited\";\r\n  }));\r\n  \r\n  // Show attack paths for all queens\r\n  queens.forEach(({row, col}) => {\r\n    // Highlight row\r\n    for (let c = 0; c < terrain.grid[0].length; c++) {\r\n      if (c !== col) terrain.grid[row][c].status = \"attack\";\r\n    }\r\n    // Highlight column\r\n    for (let r = 0; r < terrain.grid.length; r++) {\r\n      if (r !== row) terrain.grid[r][col].status = \"attack\";\r\n    }\r\n    // Highlight diagonals\r\n    for (let r = 0; r < terrain.grid.length; r++) {\r\n      for (let c = 0; c < terrain.grid[0].length; c++) {\r\n        if (Math.abs(r - row) === Math.abs(c - col) && !(r === row && c === col)) {\r\n          terrain.grid[r][c].status = \"attack\";\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n  let groundMaterial;\r\n  let groundMesh;\r\n  let mouseDownX = 0;\r\n  let mouseDownY = 0;\r\n  let previousHoverNodeId;\r\n  let currentHoverNodeId;\r\n\r\n  let mouseIsUp = true;\r\n  \r\n  const [groundGeometry, setGroundGeometry] = useState(new THREE.PlaneGeometry(300,300,30,30));\r\n  \r\n  const selectedAlgorithm = props.selectedAlgorithm;\r\n  const selectedMazeAlgorithm = props.selectedMazeAlgorithm;\r\n  const runState = props.worldProperties.runState;\r\n  const trainTheAgent = props.worldProperties.trainAgent;\r\n  const clearTheWalls = props.worldProperties.clearWalls; //rename this variable\r\n  const clearThePath = props.worldProperties.clearPath; // rename this variable too\r\n  const algorithmSpeed = props.algorithmSpeed;\r\n  const agentKnowledge = props.agentKnowledge;\r\n  const applyingSettings = props.applyingSettings;\r\n\r\n  const visualizeThePolicy = props.visualizeOptimalPolicy;\r\n  \r\n  const {\r\n    camera,\r\n  } = useThree();\r\n\r\n  useEffect(() => {\r\n    if(props.applyingSettings){\r\n      resetTerrainConfig();\r\n    }\r\n    if(props.visualizeOptimalPolicy){\r\n      calculateOptimalPolicy();\r\n      animateOptimalPolicy();\r\n      props.finishedOptimalPolicy();\r\n    }\r\n  },[applyingSettings, visualizeThePolicy]);\r\n\r\n\r\n\r\n  useEffect(() => {\r\n    if(props.agentKnowledge ===\"clearMemory\"){\r\n      terrain.records = [];\r\n      terrain.q_table = Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0));\r\n      //clearPath();\r\n      props.agentResetDone();\r\n    }\r\n    if(props.worldProperties.runState === true){\r\n      if(props.selectedAlgorithm.type === \"machine-learning\"){\r\n        animateQlearning()\r\n      }\r\n      else{\r\n      visualizeAlgorithm();\r\n      }\r\n    }\r\n    else if(props.worldProperties.clearWalls === true){\r\n      clearWalls();\r\n    }\r\n    else if(props.worldProperties.clearPath === true){\r\n      clearPath();\r\n    }\r\n    else if(props.worldProperties.trainAgent === true){\r\n      qLearning();\r\n    }\r\n    else if(props.selectedMazeAlgorithm === \"randomMaze\"){\r\n      clearPath();\r\n      let nodesToAnimate = [];\r\n      randomMaze(terrain.grid, nodesToAnimate, \"wall\");\r\n      animateMaze(nodesToAnimate, \"wall\", 30);\r\n    }\r\n    else if(props.selectedMazeAlgorithm === \"recursiveDivision\"){\r\n      clearPath();\r\n      let nodesToAnimate = [];\r\n      recursiveDivisionMaze(\r\n        terrain.grid, \r\n        2, \r\n        terrain.grid.length - 3,\r\n         2, \r\n         terrain.grid.length - 3, \r\n         \"horizontal\",\r\n         false,\r\n         nodesToAnimate,\r\n         \"wall\");\r\n\r\n         animateMaze(nodesToAnimate, \"wall\", 30)\r\n    }\r\n  }, [runState, clearTheWalls, clearThePath, selectedMazeAlgorithm, trainTheAgent,agentKnowledge,]);\r\n\r\n\r\n  const loader = useMemo(() => new THREE.TextureLoader().load(img,\r\n    function(texture){\r\n        texture.wrapS = THREE.RepeatWrapping;\r\n        texture.wrapT = THREE.RepeatWrapping;\r\n        texture.repeat.x = 30;\r\n        texture.repeat.y = 30;\r\n        groundMaterial = new THREE.MeshLambertMaterial({\r\n          map: texture,\r\n          side: THREE.FrontSide,\r\n          vertexColors: THREE.FaceColors,\r\n        });\r\n        groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);\r\n\t\t\t\tgroundMesh.receiveShadow = true;\r\n    }), [img]);\r\n\r\n    \r\n    \r\n    groundMaterial = new THREE.MeshLambertMaterial({\r\n      map: loader,\r\n      side: THREE.FrontSide,\r\n      vertexColors: THREE.FaceColors,\r\n    });\r\n\r\n    const mesh = useRef(null);\r\n    \r\n    \r\n    const [terrain, setTerrain] = useState({\r\n      grid: initializeGrid(),\r\n      states: initStates(),\r\n      q_table: Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)),\r\n      records: [],\r\n      optimalPolicy: [],\r\n      actions : { \"left\":[0,-1], \"down\":[1,0],\"right\":[0,1], \"up\":[-1,0]},\r\n      //visits: Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)),\r\n      discountFactor: 0.8,\r\n      alpha: 0.1,\r\n      start: [props.settingsConfig.startRow,props.settingsConfig.startCol],\r\n      finish: [props.settingsConfig.finishRow,props.settingsConfig.finishCol]\r\n    });\r\n\r\n  function initializeGrid(){\r\n    let tempGrid = []\r\n    for(let i = 0; i < 30; i++){\r\n        let currentRow = [];\r\n        for(let j = 0; j < 30; j++){\r\n            let node = createNode(i, j);\r\n            currentRow.push(node);\r\n        }\r\n        tempGrid.push(currentRow);\r\n    }\r\n    /*var vertices = new Float32Array(5400).fill(0);\r\n\r\n    groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute( vertices,3) );\r\n    vertices[0] = 0\r\n    vertices[1]= 1\r\n    vertices[2]= 0\r\n\r\n    \r\n\r\n    console.log(groundGeometry.getAttribute('color'))\r\n    const tween1 = new TWEEN.Tween(groundGeometry.getAttribute('color'))\r\n                    .to(new THREE.Float32BufferAttribute( vertices,2) ,9000)\r\n\r\n    tween1.start()\r\n\r\n    tween1.onUpdate(function (object: THREE.BufferAttribute | THREE.InterleavedBufferAttribute, elapsed: number){\r\n      groundGeometry.setAttribute('color',object)\r\n    })\r\n    \r\n   \r\n    //console.log(vertices)\r\n    groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute( vertices,2) );*/\r\n\r\n    //setState(tempStateGrid)\r\n    renderLoop();\r\n   return tempGrid;\r\n  }   \r\n  function visualizeAlgorithm() {\r\n  console.log(\"Visualizing algorithm:\", selectedAlgorithm.algorithm);\r\n  clearPath();\r\n  \r\n  let animations = [];\r\n  let pathNodes = [];\r\n\r\n  const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\r\n  const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\r\n\r\n  if (selectedAlgorithm.type === \"weighted\") {\r\n    const result = weightedSearchAlgorithm(\r\n      terrain.grid,\r\n      startNode,\r\n      finishNode,\r\n      animations,\r\n      selectedAlgorithm.algorithm,\r\n      selectedAlgorithm.heuristic\r\n    );\r\n    if (result === \"success!\") {\r\n      pathNodes = getNodesInShortestPathOrder(finishNode);\r\n    }\r\n  } \r\n  else if (selectedAlgorithm.type === \"unweighted\") {\r\n    const result = unweightedSearchAlgorithm(\r\n      terrain.grid,\r\n      startNode,\r\n      finishNode,\r\n      animations,\r\n      selectedAlgorithm.algorithm\r\n    );\r\n    if (result === \"success!\") {\r\n      pathNodes = getNodesInShortestPathOrder(finishNode);\r\n    }\r\n  }\r\n  else if (selectedAlgorithm.algorithm === \"nQueens\") {\r\n    const { animations: queenAnimations } = nQueensAlgorithm(terrain.grid);\r\n    animations = queenAnimations;\r\n  }\r\n\r\n  animateAlgorithm(animations, pathNodes, algorithmSpeed);\r\n  props.updateRunState(false);\r\n}\r\n\r\n  function createNode(row, col){\r\n\r\n    let status = \"default\";\r\n    let faces = {};\r\n\r\n    let faceIndex = row * 2 * props.worldProperties.cols + col * 2 ;\r\n  \r\n    faces[1] = groundGeometry.faces[faceIndex];\r\n\r\n\r\n    faceIndex = faceIndex % 2 === 0 ? faceIndex + 1 : faceIndex - 1;\r\n    faces[2] = groundGeometry.faces[faceIndex];\r\n\r\n    if(row === props.worldProperties.start.row && col === props.worldProperties.start.col){\r\n      status = \"start\";\r\n    }\r\n    else if(row === props.worldProperties.finish.row && col === props.worldProperties.finish.col){\r\n      status = \"finish\";\r\n    }\r\n    let node = {\r\n        id: row * props.worldProperties.cols + col,\r\n        row: row,\r\n        col: col,\r\n        faces: faces,\r\n        status: status,\r\n        distance: Infinity,\r\n        totalDistance: Infinity,\r\n        heuristicDistance: null,\r\n        direction: null,\r\n        weight: 0,\r\n        qValue: 0,\r\n        reward: 0,\r\n        visits: 0,\r\n        onceSpecial: false,\r\n        previousNode: null,\r\n    };\r\n    if(status === \"start\"){\r\n      node.onceSpecial = true;\r\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.start]);\r\n      \r\n    }\r\n    else if(status === \"finish\"){\r\n      node.reward = 100;\r\n      node.onceSpecial = true;\r\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.finish]);\r\n    }\r\n    return node;\r\n  }\r\n  function initStates(){\r\n    let tempStateGrid = [];\r\n    for(let row = 0; row < props.worldProperties.rows; row++){\r\n      for(let col = 0; col < props.worldProperties.cols;col++){\r\n        tempStateGrid.push([row,col]);\r\n      }\r\n    }\r\n    //console.log(tempStateGrid)\r\n    return tempStateGrid;\r\n  }\r\n  /*function initializeVisits(){\r\n    let visits = {}\r\n    let tempStates = initStates()\r\n    for(let row = 0; row < tempStates.length; row++){\r\n      for(let col = 0; col < tempStates[0].length; col++){\r\n        let state = tempStates[row][col]\r\n        visits[state] = 0;\r\n      }\r\n    }\r\n    return visits;\r\n  }*/\r\n\r\n  function renderLoop(){\r\n    window.requestAnimationFrame(renderLoop);\r\n    //if(props.resetStatus){\r\n      hoverLoop();\r\n   // }\r\n    TWEEN.update();\r\n  }\r\n\r\n  function hoverLoop(){\r\n    if(mouseIsUp || currentHoverNodeId === previousHoverNodeId){\r\n      return;\r\n    }\r\n    else{\r\n      previousHoverNodeId = currentHoverNodeId;\r\n      let nodeRow = Math.floor(currentHoverNodeId / props.worldProperties.rows);\r\n      let nodeCol = currentHoverNodeId % props.worldProperties.cols\r\n      if((nodeRow === props.worldProperties.start.row && nodeCol === props.worldProperties.start.col) \r\n        || (nodeRow === props.worldProperties.finish.row && nodeCol === props.worldProperties.finish.col)){\r\n        return;\r\n      }\r\n      else if(terrain.grid[nodeRow][nodeCol].status === \"wall\"){\r\n        terrain.grid[nodeRow][nodeCol].status = \"default\";\r\n       terrain.grid[nodeRow][nodeCol].reward = 0;\r\n        terrain.grid[nodeRow][nodeCol].visits = 0;\r\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.default]);\r\n      }\r\n      else\r\n      {\r\n        terrain.grid[nodeRow][nodeCol].status = \"wall\";\r\n        terrain.grid[nodeRow][nodeCol].visits = -1;\r\n       terrain.grid[nodeRow][nodeCol].reward = -100;\r\n        tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\r\n      }\r\n    \r\n    }\r\n    //get coordinates of node i just clicked on\r\n    \r\n  }\r\n\r\n  function mouseUpHandler(event){\r\n    if((mouseDownX !== event.clientX) || (mouseDownY !== event.clientY)){\r\n      return;\r\n    }\r\n    else\r\n    {\r\n      let nodeId = findNodeId(event.faceIndex);\r\n      if((nodeId.nodeRow === props.worldProperties.start.row && nodeId.nodeCol === props.worldProperties.start.col) \r\n        || (nodeId.nodeRow === props.worldProperties.finish.row && nodeId.nodeCol === props.worldProperties.finish.col)){\r\n      return;\r\n      }\r\n      else if(terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status === \"wall\"){\r\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = 0;\r\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"default\";\r\n        tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.default]);\r\n        //console.log(terrain.grid[nodeId.nodeRow][nodeId.nodeCol]);\r\n      }\r\n      else\r\n      {\r\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = -100;\r\n        terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"wall\";\r\n        tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\r\n        //console.log(terrain.grid[nodeId.nodeRow][nodeId.nodeCol]);\r\n      }\r\n      //console.log(terrain.grid)\r\n    }\r\n\r\n  }\r\n    \r\n  \r\n  function findNodeId(faceIndex){\r\n    let linearIndex = Math.floor(faceIndex / 2);\r\n    return {\r\n      nodeRow: Math.floor(linearIndex / props.worldProperties.rows),\r\n      nodeCol: linearIndex % props.worldProperties.cols,\r\n    }\r\n  }\r\n  function mouseDownHandler(event){\r\n      mouseDownX = event.clientX;     //set X and Y mouse coordinates when mouseDown\r\n      mouseDownY = event.clientY;\r\n  }\r\n  \r\nfunction visualizeAlgorithm() {\r\n  console.log(\"Visualizing algorithm:\", selectedAlgorithm.algorithm);\r\n  clearPath();\r\n  let nodesToAnimate = []; // Define nodesToAnimate here\r\n  let result;\r\n  \r\n  const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\r\n  const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\r\n\r\n  if (selectedAlgorithm.type === \"weighted\") {\r\n    result = weightedSearchAlgorithm(\r\n      terrain.grid,\r\n      startNode,\r\n      finishNode,\r\n      nodesToAnimate,\r\n      selectedAlgorithm.algorithm,\r\n      selectedAlgorithm.heuristic\r\n    );\r\n  } \r\n  else if (selectedAlgorithm.type === \"unweighted\") {\r\n    result = unweightedSearchAlgorithm(\r\n      terrain.grid,\r\n      startNode,\r\n      finishNode,\r\n      nodesToAnimate,\r\n      selectedAlgorithm.algorithm\r\n    );\r\n  }\r\n  else if (selectedAlgorithm.algorithm === \"nQueens\") {\r\n    nodesToAnimate = nQueensAlgorithm(\r\n      terrain.grid,\r\n      nodesToAnimate,\r\n      props.worldProperties.gridSize || 8\r\n    );\r\n    animateAlgorithm(nodesToAnimate, [], algorithmSpeed);\r\n    props.updateRunState(false);\r\n    return;\r\n  }\r\n\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n  animateAlgorithm(nodesToAnimate, nodesInShortestPathOrder, algorithmSpeed);\r\n}\r\n\r\n  // In your Grid component\r\nconst [nQueensInteractive, setNQueensInteractive] = useState(null);\r\n\r\nuseEffect(() => {\r\n  if (selectedAlgorithm.algorithm === \"nQueens\") {\r\n    setNQueensInteractive(nQueensInteractive(terrain.grid, []));\r\n  }\r\n}, [selectedAlgorithm]);\r\n\r\nfunction handleCellClick(row, col) {\r\n  if (selectedAlgorithm.algorithm === \"nQueens\" && nQueensInteractive) {\r\n    const nodesToAnimate = []; // âœ… Declare it here\r\n\r\n    if (terrain.grid[row][col].status === \"queen\") {\r\n      nQueensInteractive.removeQueen(row, col);\r\n    } else {\r\n      const success = nQueensInteractive.placeQueen(row, col);\r\n      if (!success) {\r\n        // Show error/conflict\r\n        const tempNode = { ...terrain.grid[row][col] };\r\n        tempNode.status = \"conflict\";\r\n        nodesToAnimate.push({ node: tempNode, type: \"conflict\" });\r\n      }\r\n    }\r\n\r\n    animateAlgorithm(nodesToAnimate, [], algorithmSpeed); // âœ… Now it's defined\r\n  }\r\n}\r\n\r\n\r\n// Modify your mesh click handler to use handleCellClick\r\nfunction animateAlgorithm(visitedNodes, pathNodes, speed) {\r\n  // Clear previous animations\r\n  TWEEN.removeAll();\r\n\r\n  // Animate visited nodes\r\n  visitedNodes.forEach((item, i) => {\r\n    setTimeout(() => {\r\n      if (!item.node) return;\r\n      \r\n      let color;\r\n      if (selectedAlgorithm.algorithm === \"nQueens\") {\r\n        color = item.type === \"queen\" \r\n          ? { r: 1, g: 0, b: 1 } // Purple for queens\r\n          : { r: 0.8, g: 0.8, b: 0.8 }; // Gray for visited\r\n      } else {\r\n        color = { r: 1.0, g: 0.321, b: 0.784 }; // Pink for pathfinding\r\n      }\r\n\r\n      tweenToColor(\r\n        item.node,\r\n        groundGeometry,\r\n        [color],\r\n        300,\r\n        { position: false }\r\n      );\r\n    }, speed * i);\r\n  });\r\n\r\n  // Animate path if exists\r\n  pathNodes.forEach((node, i) => {\r\n    setTimeout(() => {\r\n      tweenToColor(\r\n        node,\r\n        groundGeometry,\r\n        [props.worldProperties.colors.path],\r\n        300,\r\n        { position: false }\r\n      );\r\n    }, speed * (visitedNodes.length + i * 5));\r\n  });\r\n}\r\n  function animateShortestPath(nodesInShortestPathOrder, timerDelay){\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.path], undefined, {\r\n          position: false,\r\n        });\r\n        if (i === nodesInShortestPathOrder.length - 1) {\r\n                }\r\n      }, timerDelay * i);\r\n    }\r\n    props.updateRunState(false);\r\n    //console.log(terrain.grid[5][5]);\r\n  }\r\n\r\n  function animateQlearning(){\r\n    clearPath();\r\n    let minimum = -10;\r\n    let maximum = 100;\r\n    for(let i = 0; i < terrain.records.length;i++){\r\n      //let record = terrain.records[i]\r\n      //if(i > 1300){return;}\r\n      for(let row = 0; row < 30; row++){\r\n        for(let col = 0; col < 30; col++){ \r\n          const node = terrain.grid[row][col];\r\n          if(terrain.records[i][row][col] === 0 || node.status === \"wall\" || node.status === \"start\" || node.status === \"finish\"){continue;}\r\n          let ratio = 2 * (terrain.records[i][row][col]-minimum) / (maximum - minimum)\r\n          let blue = Number(Math.max(0, 255*(1 - ratio)))\r\n          let red = Number(Math.max(0, 255*(ratio - 1)))\r\n          let green = 255 - blue - red\r\n\r\n          red /= 255;\r\n          green /= 255;\r\n          blue /= 255;\r\n          \r\n          setTimeout(() => {\r\n            tweenToColor(node, groundGeometry, [{r: red, g: green, b: blue}], 5,{position: false});\r\n            //if (row === 30 - 1) {}\r\n          }, 1000);\r\n        }\r\n      }\r\n    }\r\n    props.updateRunState(false);\r\n  }\r\n  function animateOptimalPolicy(){\r\n    for(let i = 2; i < terrain.optimalPolicy.length;i++){\r\n      let headRow = terrain.optimalPolicy[i][0];\r\n      let headCol = terrain.optimalPolicy[i][1];\r\n      //let torsoRow = terrain.optimalPolicy[i-1][0];\r\n      //let torsoCol = terrain.optimalPolicy[i-1][1];\r\n      let tailRow = terrain.optimalPolicy[i-1][0];\r\n      let tailCol = terrain.optimalPolicy[i-1][1];\r\n\r\n      const head = terrain.grid[headRow][headCol];\r\n      //const torso = terrain.grid[torsoRow][torsoCol];\r\n      const tail = terrain.grid[tailRow][tailCol];\r\n      if (head.status === 'start'|| tail.status == 'start'){continue;}\r\n\r\n\r\n      setTimeout(() => {\r\n        if (head.status === 'finish' ) return;\r\n        //terrain.grid[row][col].status = visited;\r\n        \r\n        //setTimeout(() => {\r\n        //tweenToColor(tail, groundGeometry, [props.worldProperties.colors.path], undefined,{position: false});\r\n        //}, i*props.algorithmSpeed);\r\n\r\n\r\n        tweenToColor(tail, groundGeometry, [props.worldProperties.colors.path], undefined,{position: false});\r\n        tweenToColor(head, groundGeometry, [{r: 0, g: 0, b: 0}], undefined,{position: false});\r\n        //tweenToColor(torso, groundGeometry, [{r: 0, g: 0, b: 0}], undefined,{position: false});\r\n\r\n      }, 5*i*props.algorithmSpeed);\r\n\r\n    }\r\n  }\r\n  function qLearning(){\r\n    //reset records\r\n    if(props.settingsConfig.epochs > 0){\r\n      terrain.records = [];\r\n    }\r\n    //let i = 0;\r\n    //while(terrain.records.length < 1000){\r\n    for(let i = 0; i < props.settingsConfig.epochs; i++){\r\n      //if(terrain.records.length > 1300){break;}\r\n      if(i > 0.75*props.settingsConfig.epochs){\r\n        let y = props.settingsConfig.startRow;\r\n        let x = props.settingsConfig.startCol;\r\n        var currentState = [y,x]; \r\n      }\r\n      else{\r\n        var currentState = terrain.states[Math.floor(Math.random() * terrain.states.length)]\r\n\r\n      }\r\n      var steps = 0;\r\n      while(!(currentState[0] === props.settingsConfig.finishRow && currentState[1] === props.settingsConfig.finishCol)\r\n        && terrain.grid[currentState[0]][currentState[1]].status !== \"wall\" && steps < 1000){\r\n        \r\n          //setTimeout(() => {\r\n           //tweenToColor(terrain.grid[14][14],groundGeometry,[{ r: 1, g: 0.64, b: 0.0}]);\r\n          //}, props.algorithmSpeed);\r\n          \r\n          \r\n          //let action = chooseAction(currentState, Math.abs(1- (i/props.settingsConfig.epochs)))\r\n          var curiosity = props.settingsConfig.agentCuriosity;\r\n          if(i > 0.75*props.settingsConfig.epochs){\r\n            curiosity = 0.4;\r\n          }\r\n          let action = chooseAction(currentState, curiosity)\r\n          let action_dy = terrain.actions[action][0]\r\n\t\t\t\t  let action_dx = terrain.actions[action][1]\r\n\t\t\t\t  let nextState = [action_dy + currentState[0], action_dx + currentState[1]]\r\n\r\n\r\n          let currentQValue = terrain.q_table[currentState[0]][currentState[1]]\r\n\t\t\t\t  //let maximum_action = chooseAction(currentState, 0)//might need to be nextstate\r\n\t\t\t\t\r\n          //action_dy = terrain.actions[maximum_action][0]\r\n\t\t\t\t  //action_dx = terrain.actions[maximum_action][1]\r\n\r\n\t\t\t\t  let maxState = [action_dy + currentState[0], action_dx + currentState[1]];\r\n\t\t\t\t  let maxQValue = terrain.q_table[maxState[0]][maxState[1]]\r\n\r\n          let temporal_difference = (terrain.grid[nextState[0]][nextState[1]].reward + terrain.discountFactor *(maxQValue - currentQValue)  ); \r\n\t\t\t\t  \r\n          //let learning_rate = 1 / (1 + terrain.grid[currentState[0]][currentState[1]].visits)\r\n\r\n          let q_value = currentQValue + (props.settingsConfig.learningRate * (temporal_difference));\r\n\t\t\t\t  terrain.q_table[currentState[0]][currentState[1]] = parseFloat(q_value.toFixed(2));\r\n\r\n          terrain.grid[currentState[0]][currentState[1]].visits+=1;\r\n          currentState = nextState;\r\n          steps++;\r\n         \r\n\r\n      }\r\n        //i++;\r\n        terrain.records.push(getRecord())\r\n    }\r\n    props.stopTraining();\r\n    //console.log(props.settingsConfig.epochs);\r\n    console.log(terrain.records)\r\n    //console.log(terrain.grid)\r\n  }\r\n  function chooseAction(currentState,e_greedy){\r\n    var rwc = require(\"random-weighted-choice\");\r\n    \r\n    let actionOptions = [\r\n      {weight: e_greedy * 10, id: \"true\"},\r\n      {weight: 10*(1 - e_greedy), id: \"false\"}\r\n    ];\r\n    let chosenOption = rwc(actionOptions)\r\n    let takingRandomAction = (chosenOption === \"true\");//true or false;\r\n    let actions = [\"left\",\"down\",\"right\",\"up\"];\r\n    \r\n    if(takingRandomAction){\r\n      //console.log(\"Taking random action\");\r\n      //let random_index = random.randint(0,len(actions) - 1)\r\n      while(true){\r\n        let randomIndex = Math.floor(Math.random() * actions.length)\r\n\t\t\t  let selectedAction = actions[randomIndex]\r\n\t\t\t  let actionChange = terrain.actions[selectedAction]\r\n        if(isValidState([actionChange[0] + currentState[0],actionChange[1] + currentState[1]])){\r\n          //console.log(\"When action is random action is: \" + selectedAction)\r\n          return selectedAction;\r\n        }\r\n      }\r\n    }\r\n    else{\r\n      //console.log(\"Taking greedy action\");\r\n      //let policyCandidates = new WeakMap();\r\n      let policyCandidates = {};\r\n      for(let action in terrain.actions){\r\n        let nextState = [terrain.actions[action][0]+currentState[0],terrain.actions[action][1]+currentState[1]]\r\n        //console.log(nextState)\r\n        if (isValidState(nextState)){\r\n\t\t\t\t  //console.log(terrain.q_table);\r\n\t\t\t\t\tpolicyCandidates[nextState] = terrain.q_table[nextState[0]][nextState[1]]\r\n          //policyCandidates.set(nextState,terrain.q_table[nextState[1]][nextState[0]]);\r\n        }\r\n      }\r\n      //let maxState = max(policy_candidates, key=policy_candidates.get)\r\n      let maxQValue = Number(Object.keys(policyCandidates).reduce((a, v) => Math.max(a, policyCandidates[v]), -Infinity));\r\n      let maxState = Object.keys(policyCandidates).filter(v => policyCandidates[v] === maxQValue);\r\n\r\n\t\t\t//let maxQValue = policy_candidates[maxState]\r\n\t\t\tlet listOfMax = [];\r\n      for(let maxCandidate in policyCandidates){\r\n        if(policyCandidates[maxCandidate] === maxQValue){\r\n          let tempVals = maxCandidate.split(\",\").map(Number)\r\n          listOfMax.push(tempVals);\r\n        }\r\n      }\r\n      let randomIndex = Math.floor(Math.random() * listOfMax.length);\r\n\t\t\tmaxState = listOfMax[randomIndex];\r\n      //console.log(listOfMax)\r\n      //Now we can use the max_state(state with the maximum q value to find the actioned perfomed to get there)\r\n\t\t\tlet action_dy = maxState[0] - currentState[0];\r\n\t\t\tlet action_dx = maxState[1] - currentState[1];\r\n\r\n      for(let action in terrain.actions){\r\n        if(terrain.actions[action][0] === action_dy && terrain.actions[action][1] === action_dx){\r\n          return action;\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n  function isValidState(nextState){\r\n    //console.log(nextState)\r\n    if (nextState[0] < 0 || nextState[0] >= props.worldProperties.rows || \r\n        nextState[1] < 0 || nextState[1] >= props.worldProperties.cols){return false;}\r\n\t\treturn true\r\n  }\r\n  function getRecord(){\r\n    let record =  Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0))\r\n    for(let i = 0; i < terrain.states.length; i++){\r\n      let state = terrain.states[i]\r\n\t\t\trecord[state[0]][state[1]] = terrain.q_table[state[0]][state[1]]\r\n    }\r\n    //console.log(record)\r\n    return record;\r\n  }\r\n  function resetTerrainConfig(){\r\n    for(let row = 0; row < 30; row++){\r\n      for(let col = 0; col < 30; col++){\r\n        if(terrain.grid[row][col].status === \"wall\"){\r\n          continue;\r\n        }\r\n        if(row === props.settingsConfig.startRow && col  === props.settingsConfig.startCol){\r\n          terrain.grid[row][col].status = \"start\";\r\n          terrain.grid[row][col].onceSpecial = true;\r\n        }\r\n        else if(row === props.settingsConfig.finishRow && col === props.settingsConfig.finishCol){\r\n          terrain.grid[row][col].status = \"finish\";\r\n          terrain.grid[row][col].reward = 100;\r\n          terrain.grid[row][col].onceSpecial = true;\r\n\r\n        }\r\n        else{\r\n          terrain.grid[row][col].status = \"default\";\r\n          terrain.grid[row][col].reward = 0;\r\n          if(terrain.grid[row][col].onceSpecial){\r\n          tweenToColor(terrain.grid[row][col], groundGeometry, [props.worldProperties.colors.default]);\r\n          }\r\n\r\n        }\r\n      }\r\n    }\r\n    //console.log(terrain.records)\r\n    props.finishApplyingSettings();\r\n  }\r\n\r\n  function calculateOptimalPolicy(){\r\n    let currentState = [props.settingsConfig.startRow, props.settingsConfig.startCol];\r\n    let policyList = [];\r\n    policyList.push(currentState);\r\n    \r\n    while(!(currentState[0] === props.settingsConfig.finishRow && currentState[1] === props.settingsConfig.finishCol)\r\n    && terrain.grid[currentState[0]][currentState[1]].status !== \"wall\"){\r\n      let maxAction = chooseAction(currentState,props.policyCuriosity);\r\n      let action_dy = terrain.actions[maxAction][0];\r\n      let action_dx = terrain.actions[maxAction][1];\r\n\r\n      let nextState = [action_dy + currentState[0], action_dx + currentState[1]];\r\n      policyList.push(nextState);\r\n      currentState = nextState;\r\n      //console.log(maxAction);\r\n      //console.log(action_dy);\r\n    }\r\n    terrain.optimalPolicy = policyList; \r\n  }\r\n\r\n  function clearWalls(){\r\n    for(let i = 0; i < props.worldProperties.rows; i++){\r\n      for(let j = 0; j < props.worldProperties.cols; j++){\r\n        if(terrain.grid[i][j].status === \"wall\" || terrain.q_table[i][j] < 0){\r\n          terrain.grid[i][j].status = \"default\";\r\n          terrain.grid[i][j].reward = 0;\r\n          tweenToColor(terrain.grid[i][j], groundGeometry, [props.worldProperties.colors.default])\r\n        }\r\n      }\r\n    }\r\n    props.stopClearWalls();\r\n  }\r\n  function clearPath(){\r\n    TWEEN.removeAll();\r\n    for(let i = 0; i < props.worldProperties.rows; i++){\r\n      for(let j = 0; j < props.worldProperties.cols; j++){\r\n        if(i === props.worldProperties.start.row && j === props.worldProperties.start.col){\r\n          terrain.grid[i][j].status = \"start\";\r\n          terrain.grid[i][j].visits = -1; \r\n        }\r\n        if(i === props.worldProperties.finish.row && j === props.worldProperties.finish.col){\r\n          terrain.grid[i][j].status = \"finish\"; \r\n        }\r\n        \r\n        if(terrain.grid[i][j].status === \"visited\" || terrain.grid[i][j].visits > 0 ){\r\n          terrain.grid[i][j].status = \"default\";\r\n          tweenToColor(terrain.grid[i][j], groundGeometry, [props.worldProperties.colors.default]);\r\n        }\r\n        terrain.grid[i][j].distance = Infinity;\r\n        terrain.grid[i][j].totalDistance = Infinity;\r\n        terrain.grid[i][j].heuristicDistance = null;\r\n        terrain.grid[i][j].direction = null;\r\n        terrain.grid[i][j].previousNode = null;\r\n      }\r\n    }\r\n    props.stopClearPath();\r\n  }\r\n  function animateMaze(nodesToAnimate, type, timerDelay){\r\n    clearWalls();\r\n    for(let i = 0; i < nodesToAnimate.length; i++){\r\n      let nodeRow = nodesToAnimate[i].row;\r\n      let nodeCol = nodesToAnimate[i].col\r\n      setTimeout(() => {\r\n        //const node = nodesToAnimate[i];\r\n       // node.status = type;\r\n       terrain.grid[nodeRow][nodeCol].status = \"wall\";\r\n       terrain.grid[nodeRow][nodeCol].reward = -100;\r\n       terrain.grid[nodeRow][nodeCol].visits = -1;\r\n      tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\r\n      }, timerDelay * i);\r\n      props.stopMazeSelection();\r\n    }\r\n  }\r\n return (\r\n    <mesh ref={mesh} position={[0, 0, 0]}>\r\n      <gridHelper args={[300, props.gridDimensions, 0x5c78bd, 0x5c78bd]} />\r\n      <mesh \r\n        rotation={[-Math.PI / 2, 0, 0]} \r\n        position={[0, -0.1, 0]} \r\n        receiveShadow={true}\r\n        onPointerDown={(e) => {\r\n          mouseIsUp = false;\r\n          mouseDownHandler(e);\r\n        }}\r\n        onPointerUp={e => {\r\n          if (props.resetStatus === true || mouseIsUp === true) {\r\n            mouseIsUp = true;\r\n          }\r\n          mouseUpHandler(e);\r\n        }}\r\n        onPointerMove={e => {\r\n          if (mouseIsUp === true || props.resetStatus === false) {\r\n            return;\r\n          }\r\n          else if (mouseIsUp === false) {\r\n            currentHoverNodeId = Math.floor(e.faceIndex / 2);\r\n            return;\r\n          }\r\n        }}\r\n      >\r\n        <primitive attach='geometry' object={groundGeometry} />  \r\n        <primitive attach='material' object={groundMaterial} />   \r\n      </mesh>\r\n      <axesHelper />\r\n    </mesh>\r\n  );\r\n}\r\n\r\nexport default Grid;"]},"metadata":{},"sourceType":"module"}