{"ast":null,"code":"export function randomMaze(grid, nodesToAnimate, type) {\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[0].length; j++) {\n      let random = Math.random();\n      let currentNode = grid[i][j];\n      let reservedStatus = [\"start\", \"finish\"];\n      let randomTwo = type === \"wall\" ? 0.25 : 0.35;\n\n      if (random < randomTwo && !reservedStatus.includes(currentNode.status)) {\n        nodesToAnimate.push(currentNode);\n\n        if (type === \"wall\") {\n          // currentNode.status = \"wall\";\n          currentNode.weight = 0;\n        } else if (type === \"weight\") {\n          // currentNode.status = \"default\";  // should be \"weight\"; left for later implementation\n          currentNode.weight = 15;\n        }\n      }\n    }\n  }\n}\nexport function recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type) {\n  if (rowEnd < rowStart || colEnd < colStart) {\n    return;\n  }\n\n  let reservedStatus = [\"start\", \"finish\"];\n\n  function converNodeToType(node) {\n    if (reservedStatus.includes(node.status)) return;\n    nodesToAnimate.push(node);\n\n    if (type === \"wall\") {\n      // node.status = \"wall\";\n      node.weight = 0;\n    } else if (type === \"weight\") {\n      // node.status = \"default\";  // should be \"weight\"; left for later implementation\n      node.weight = 15;\n    }\n  }\n\n  if (!surroundingWalls) {\n    let i, j; //First row\n\n    for (j = 0; j < grid[0].length; j++) {\n      i = 0;\n      converNodeToType(grid[i][j]);\n    } //Last row\n\n\n    for (j = 0; j < grid[0].length; j++) {\n      i = grid.length - 1;\n      converNodeToType(grid[i][j]);\n    } //First column\n\n\n    for (i = 1; i < grid.length - 1; i++) {\n      j = 0;\n      converNodeToType(grid[i][j]);\n    } //Last column\n\n\n    for (i = 1; i < grid.length - 1; i++) {\n      j = grid[0].length - 1;\n      converNodeToType(grid[i][j]);\n    }\n\n    surroundingWalls = true;\n  }\n\n  if (orientation === \"horizontal\") {\n    let possibleRows = [];\n\n    for (let number = rowStart; number <= rowEnd; number += 2) {\n      possibleRows.push(number);\n    }\n\n    let possibleCols = [];\n\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\n      possibleCols.push(number);\n    }\n\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let currentRow = possibleRows[randomRowIndex];\n    let colRandom = possibleCols[randomColIndex];\n    let i = currentRow,\n        j;\n\n    for (j = colStart - 1; j <= colEnd + 1; j++) {\n      if (j !== colRandom) {\n        converNodeToType(grid[i][j]);\n      }\n    }\n\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\n      recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, \"vertical\", surroundingWalls, nodesToAnimate, type);\n    }\n\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\n      recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls, nodesToAnimate, type);\n    }\n  } else {\n    let possibleCols = [];\n\n    for (let number = colStart; number <= colEnd; number += 2) {\n      possibleCols.push(number);\n    }\n\n    let possibleRows = [];\n\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\n      possibleRows.push(number);\n    }\n\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\n    let currentCol = possibleCols[randomColIndex];\n    let rowRandom = possibleRows[randomRowIndex];\n    let i,\n        j = currentCol;\n\n    for (i = rowStart - 1; i <= rowEnd + 1; i++) {\n      if (i !== rowRandom) {\n        converNodeToType(grid[i][j]);\n      }\n    }\n\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, orientation, surroundingWalls, nodesToAnimate, type);\n    }\n\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingWalls, nodesToAnimate, type);\n    } else {\n      recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\n    }\n  }\n}\n;","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/mazeAlgorithms.js"],"names":["randomMaze","grid","nodesToAnimate","type","i","length","j","random","Math","currentNode","reservedStatus","randomTwo","includes","status","push","weight","recursiveDivisionMaze","rowStart","rowEnd","colStart","colEnd","orientation","surroundingWalls","converNodeToType","node","possibleRows","number","possibleCols","randomRowIndex","floor","randomColIndex","currentRow","colRandom","currentCol","rowRandom"],"mappings":"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","sourcesContent":["export function randomMaze(grid, nodesToAnimate, type) {\r\n\tfor(let i=0; i<grid.length; i++) {\r\n\t\tfor(let j=0; j<grid[0].length; j++) {\r\n\t\t\tlet random = Math.random();\r\n\t\t\tlet currentNode = grid[i][j];\r\n\t\t\tlet reservedStatus = [\"start\", \"finish\"];\r\n\t\t\tlet randomTwo = type === \"wall\" ? 0.25 : 0.35;\r\n\t\t\tif (random < randomTwo && !reservedStatus.includes(currentNode.status)) {\r\n\t\t\t\tnodesToAnimate.push(currentNode);\r\n\t\t\t\tif (type === \"wall\") {\r\n\t\t\t\t\t// currentNode.status = \"wall\";\r\n\t\t\t\t\tcurrentNode.weight = 0;\r\n\t\t\t\t} else if (type === \"weight\") {\r\n\t\t\t\t\t// currentNode.status = \"default\";  // should be \"weight\"; left for later implementation\r\n\t\t\t\t\tcurrentNode.weight = 15;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type) {\r\n  if (rowEnd < rowStart || colEnd < colStart) {\r\n    return;\r\n\t}\r\n\r\n\tlet reservedStatus = [\"start\", \"finish\"];\r\n\tfunction converNodeToType(node) {\r\n\t\tif(reservedStatus.includes(node.status)) return;\r\n\t\tnodesToAnimate.push(node);\r\n\t\tif (type === \"wall\") {\r\n\t\t\t// node.status = \"wall\";\r\n\t\t\tnode.weight = 0;\r\n\t\t} else if (type === \"weight\") {\r\n\t\t\t// node.status = \"default\";  // should be \"weight\"; left for later implementation\r\n\t\t\tnode.weight = 15;\r\n\t\t}\r\n\t}\r\n\r\n  if (!surroundingWalls) {\r\n\t\tlet i, j;\r\n\t\t//First row\r\n\t\tfor(j=0; j<grid[0].length; j++) {\r\n\t\t\ti = 0;\r\n\t\t\tconverNodeToType(grid[i][j]);\r\n\t\t}\r\n\t\t//Last row\r\n\t\tfor(j=0; j<grid[0].length; j++) {\r\n\t\t\ti = grid.length-1;\r\n\t\t\tconverNodeToType(grid[i][j]);\r\n\t\t}\r\n\t\t//First column\r\n\t\tfor(i=1; i<grid.length-1; i++) {\r\n\t\t\tj = 0;\r\n\t\t\tconverNodeToType(grid[i][j]);\r\n\t\t}\r\n\t\t//Last column\r\n\t\tfor(i=1; i<grid.length-1; i++) {\r\n\t\t\tj = grid[0].length-1;\r\n\t\t\tconverNodeToType(grid[i][j]);\r\n\t\t}\r\n    surroundingWalls = true;\r\n  }\r\n  if (orientation === \"horizontal\") {\r\n    let possibleRows = [];\r\n    for (let number = rowStart; number <= rowEnd; number += 2) {\r\n      possibleRows.push(number);\r\n    }\r\n    let possibleCols = [];\r\n    for (let number = colStart - 1; number <= colEnd + 1; number += 2) {\r\n      possibleCols.push(number);\r\n    }\r\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n    let currentRow = possibleRows[randomRowIndex];\r\n\t\tlet colRandom = possibleCols[randomColIndex];\r\n\t\t\r\n\t\tlet i = currentRow, j;\r\n\t\tfor(j=colStart-1; j<=colEnd+1; j++) {\r\n\t\t\tif(j !== colRandom) {\r\n\t\t\t\tconverNodeToType(grid[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n    if (currentRow - 2 - rowStart > colEnd - colStart) {\r\n      recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\r\n    } else {\r\n      recursiveDivisionMaze(grid, rowStart, currentRow - 2, colStart, colEnd, \"vertical\", surroundingWalls, nodesToAnimate, type);\r\n    }\r\n    if (rowEnd - (currentRow + 2) > colEnd - colStart) {\r\n      recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\r\n    } else {\r\n      recursiveDivisionMaze(grid, currentRow + 2, rowEnd, colStart, colEnd, \"vertical\", surroundingWalls, nodesToAnimate, type);\r\n    }\r\n  } else {\r\n    let possibleCols = [];\r\n    for (let number = colStart; number <= colEnd; number += 2) {\r\n      possibleCols.push(number);\r\n    }\r\n    let possibleRows = [];\r\n    for (let number = rowStart - 1; number <= rowEnd + 1; number += 2) {\r\n      possibleRows.push(number);\r\n    }\r\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n    let currentCol = possibleCols[randomColIndex];\r\n\t\tlet rowRandom = possibleRows[randomRowIndex];\r\n\r\n\t\tlet i, j = currentCol;\r\n\t\tfor(i=rowStart-1; i<=rowEnd+1; i++) {\r\n\t\t\tif(i !== rowRandom) {\r\n\t\t\t\tconverNodeToType(grid[i][j]);\r\n\t\t\t}\r\n\t\t}\r\n    if (rowEnd - rowStart > currentCol - 2 - colStart) {\r\n      recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, \"horizontal\", surroundingWalls, nodesToAnimate, type);\r\n    } else {\r\n      recursiveDivisionMaze(grid, rowStart, rowEnd, colStart, currentCol - 2, orientation, surroundingWalls, nodesToAnimate, type);\r\n    }\r\n    if (rowEnd - rowStart > colEnd - (currentCol + 2)) {\r\n      recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, \"horizontal\", surroundingWalls, nodesToAnimate, type);\r\n    } else {\r\n      recursiveDivisionMaze(grid, rowStart, rowEnd, currentCol + 2, colEnd, orientation, surroundingWalls, nodesToAnimate, type);\r\n    }\r\n\t}\r\n};"]},"metadata":{},"sourceType":"module"}