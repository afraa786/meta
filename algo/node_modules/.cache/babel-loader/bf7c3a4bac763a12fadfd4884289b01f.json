{"ast":null,"code":"export function nQueensAlgorithm(grid, nodesToAnimate, size = 8) {\n  const boardSize = size;\n  const queens = []; // Reset grid statuses first (preserve walls)\n\n  for (let row = 0; row < boardSize; row++) {\n    for (let col = 0; col < boardSize; col++) {\n      if (grid[row][col].status !== \"wall\") {\n        grid[row][col].status = \"unvisited\";\n      }\n    }\n  }\n\n  function isSafe(row, col) {\n    // Don't place queens on walls\n    if (grid[row][col].status === \"wall\") return false;\n\n    for (let i = 0; i < queens.length; i++) {\n      const [qRow, qCol] = queens[i];\n      if (qCol === col || // Same column\n      qRow - qCol === row - col || // Same diagonal\n      qRow + qCol === row + col // Same anti-diagonal\n      ) return false;\n    }\n\n    return true;\n  }\n\n  function solve(row = 0) {\n    if (row === boardSize) return true;\n\n    for (let col = 0; col < boardSize; col++) {\n      if (isSafe(row, col)) {\n        queens.push([row, col]);\n        let node = grid[row][col];\n        node.status = \"queen\";\n        nodesToAnimate.push({ ...node\n        });\n        if (solve(row + 1)) return true; // Backtrack\n\n        queens.pop();\n        node.status = \"visited\";\n        nodesToAnimate.push({ ...node\n        });\n      }\n    }\n\n    return false;\n  }\n\n  solve();\n  return \"done\";\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/Grid.js"],"names":["nQueensAlgorithm","grid","nodesToAnimate","size","boardSize","queens","row","col","status","isSafe","i","length","qRow","qCol","solve","push","node","pop"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,cAAhC,EAAgDC,IAAI,GAAG,CAAvD,EAA0D;AAC7D,QAAMC,SAAS,GAAGD,IAAlB;AACA,QAAME,MAAM,GAAG,EAAf,CAF6D,CAI7D;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,SAAxB,EAAmCE,GAAG,EAAtC,EAA0C;AACtC,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACtC,UAAIN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC;AAClCP,QAAAA,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,GAAwB,WAAxB;AACH;AACJ;AACJ;;AAED,WAASC,MAAT,CAAgBH,GAAhB,EAAqBC,GAArB,EAA0B;AACtB;AACA,QAAIN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC,OAAO,KAAP;;AAEtC,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,MAAM,CAACM,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACpC,YAAM,CAACE,IAAD,EAAOC,IAAP,IAAeR,MAAM,CAACK,CAAD,CAA3B;AACA,UACIG,IAAI,KAAKN,GAAT,IAA0B;AAC1BK,MAAAA,IAAI,GAAGC,IAAP,KAAgBP,GAAG,GAAGC,GADtB,IAC6B;AAC7BK,MAAAA,IAAI,GAAGC,IAAP,KAAgBP,GAAG,GAAGC,GAH1B,CAGiC;AAHjC,QAIE,OAAO,KAAP;AACL;;AACD,WAAO,IAAP;AACH;;AAED,WAASO,KAAT,CAAeR,GAAG,GAAG,CAArB,EAAwB;AACpB,QAAIA,GAAG,KAAKF,SAAZ,EAAuB,OAAO,IAAP;;AAEvB,SAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACtC,UAAIE,MAAM,CAACH,GAAD,EAAMC,GAAN,CAAV,EAAsB;AAClBF,QAAAA,MAAM,CAACU,IAAP,CAAY,CAACT,GAAD,EAAMC,GAAN,CAAZ;AACA,YAAIS,IAAI,GAAGf,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,CAAX;AACAS,QAAAA,IAAI,CAACR,MAAL,GAAc,OAAd;AACAN,QAAAA,cAAc,CAACa,IAAf,CAAoB,EAAC,GAAGC;AAAJ,SAApB;AAEA,YAAIF,KAAK,CAACR,GAAG,GAAG,CAAP,CAAT,EAAoB,OAAO,IAAP,CANF,CAQlB;;AACAD,QAAAA,MAAM,CAACY,GAAP;AACAD,QAAAA,IAAI,CAACR,MAAL,GAAc,SAAd;AACAN,QAAAA,cAAc,CAACa,IAAf,CAAoB,EAAC,GAAGC;AAAJ,SAApB;AACH;AACJ;;AACD,WAAO,KAAP;AACH;;AAEDF,EAAAA,KAAK;AACL,SAAO,MAAP;AACH","sourcesContent":["export function nQueensAlgorithm(grid, nodesToAnimate, size = 8) {\r\n    const boardSize = size;\r\n    const queens = [];\r\n    \r\n    // Reset grid statuses first (preserve walls)\r\n    for (let row = 0; row < boardSize; row++) {\r\n        for (let col = 0; col < boardSize; col++) {\r\n            if (grid[row][col].status !== \"wall\") {\r\n                grid[row][col].status = \"unvisited\";\r\n            }\r\n        }\r\n    }\r\n\r\n    function isSafe(row, col) {\r\n        // Don't place queens on walls\r\n        if (grid[row][col].status === \"wall\") return false;\r\n        \r\n        for (let i = 0; i < queens.length; i++) {\r\n            const [qRow, qCol] = queens[i];\r\n            if (\r\n                qCol === col ||           // Same column\r\n                qRow - qCol === row - col || // Same diagonal\r\n                qRow + qCol === row + col    // Same anti-diagonal\r\n            ) return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function solve(row = 0) {\r\n        if (row === boardSize) return true;\r\n\r\n        for (let col = 0; col < boardSize; col++) {\r\n            if (isSafe(row, col)) {\r\n                queens.push([row, col]);\r\n                let node = grid[row][col];\r\n                node.status = \"queen\";\r\n                nodesToAnimate.push({...node});\r\n                \r\n                if (solve(row + 1)) return true;\r\n\r\n                // Backtrack\r\n                queens.pop();\r\n                node.status = \"visited\";\r\n                nodesToAnimate.push({...node});\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    solve();\r\n    return \"done\";\r\n}"]},"metadata":{},"sourceType":"module"}