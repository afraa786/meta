{"ast":null,"code":"export function nQueensAlgorithm(grid, nodesToAnimate = [], size = 8) {\n  const boardSize = size;\n  const queens = []; // Reset grid statuses (preserve walls)\n\n  for (let row = 0; row < boardSize; row++) {\n    for (let col = 0; col < boardSize; col++) {\n      if (grid[row][col].status !== \"wall\") {\n        grid[row][col].status = \"unvisited\";\n      }\n    }\n  }\n\n  function isSafe(row, col) {\n    // Don't place queens on walls\n    if (grid[row][col].status === \"wall\") return false;\n\n    for (const [qRow, qCol] of queens) {\n      if (qCol === col || qRow - qCol === row - col || qRow + qCol === row + col) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function solve(row = 0) {\n    if (row === boardSize) return true;\n\n    for (let col = 0; col < boardSize; col++) {\n      if (isSafe(row, col)) {\n        queens.push([row, col]);\n        const node = grid[row][col];\n        node.status = \"queen\";\n        nodesToAnimate.push({\n          node: { ...node\n          },\n          type: \"queen\"\n        });\n        if (solve(row + 1)) return true; // Backtrack\n\n        queens.pop();\n        node.status = \"visited\";\n        nodesToAnimate.push({\n          node: { ...node\n          },\n          type: \"visited\"\n        });\n      }\n    }\n\n    return false;\n  }\n\n  solve();\n  return nodesToAnimate;\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/nQueens.js"],"names":["nQueensAlgorithm","grid","nodesToAnimate","size","boardSize","queens","row","col","status","isSafe","qRow","qCol","solve","push","node","type","pop"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,cAAc,GAAG,EAAjD,EAAqDC,IAAI,GAAG,CAA5D,EAA+D;AACpE,QAAMC,SAAS,GAAGD,IAAlB;AACA,QAAME,MAAM,GAAG,EAAf,CAFoE,CAIpE;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,SAAxB,EAAmCE,GAAG,EAAtC,EAA0C;AACxC,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACxC,UAAIN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC;AACpCP,QAAAA,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,GAAwB,WAAxB;AACD;AACF;AACF;;AAED,WAASC,MAAT,CAAgBH,GAAhB,EAAqBC,GAArB,EAA0B;AACxB;AACA,QAAIN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC,OAAO,KAAP;;AAEtC,SAAK,MAAM,CAACE,IAAD,EAAOC,IAAP,CAAX,IAA2BN,MAA3B,EAAmC;AACjC,UAAIM,IAAI,KAAKJ,GAAT,IAAgBG,IAAI,GAAGC,IAAP,KAAgBL,GAAG,GAAGC,GAAtC,IAA6CG,IAAI,GAAGC,IAAP,KAAgBL,GAAG,GAAGC,GAAvE,EAA4E;AAC1E,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAED,WAASK,KAAT,CAAeN,GAAG,GAAG,CAArB,EAAwB;AACtB,QAAIA,GAAG,KAAKF,SAAZ,EAAuB,OAAO,IAAP;;AAEvB,SAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACxC,UAAIE,MAAM,CAACH,GAAD,EAAMC,GAAN,CAAV,EAAsB;AACpBF,QAAAA,MAAM,CAACQ,IAAP,CAAY,CAACP,GAAD,EAAMC,GAAN,CAAZ;AACA,cAAMO,IAAI,GAAGb,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,CAAb;AACAO,QAAAA,IAAI,CAACN,MAAL,GAAc,OAAd;AACAN,QAAAA,cAAc,CAACW,IAAf,CAAoB;AAACC,UAAAA,IAAI,EAAE,EAAC,GAAGA;AAAJ,WAAP;AAAkBC,UAAAA,IAAI,EAAE;AAAxB,SAApB;AAEA,YAAIH,KAAK,CAACN,GAAG,GAAG,CAAP,CAAT,EAAoB,OAAO,IAAP,CANA,CAQpB;;AACAD,QAAAA,MAAM,CAACW,GAAP;AACAF,QAAAA,IAAI,CAACN,MAAL,GAAc,SAAd;AACAN,QAAAA,cAAc,CAACW,IAAf,CAAoB;AAACC,UAAAA,IAAI,EAAE,EAAC,GAAGA;AAAJ,WAAP;AAAkBC,UAAAA,IAAI,EAAE;AAAxB,SAApB;AACD;AACF;;AACD,WAAO,KAAP;AACD;;AAEDH,EAAAA,KAAK;AACL,SAAOV,cAAP;AACD","sourcesContent":["export function nQueensAlgorithm(grid, nodesToAnimate = [], size = 8) {\r\n  const boardSize = size;\r\n  const queens = [];\r\n  \r\n  // Reset grid statuses (preserve walls)\r\n  for (let row = 0; row < boardSize; row++) {\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (grid[row][col].status !== \"wall\") {\r\n        grid[row][col].status = \"unvisited\";\r\n      }\r\n    }\r\n  }\r\n\r\n  function isSafe(row, col) {\r\n    // Don't place queens on walls\r\n    if (grid[row][col].status === \"wall\") return false;\r\n    \r\n    for (const [qRow, qCol] of queens) {\r\n      if (qCol === col || qRow - qCol === row - col || qRow + qCol === row + col) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function solve(row = 0) {\r\n    if (row === boardSize) return true;\r\n\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (isSafe(row, col)) {\r\n        queens.push([row, col]);\r\n        const node = grid[row][col];\r\n        node.status = \"queen\";\r\n        nodesToAnimate.push({node: {...node}, type: \"queen\"});\r\n        \r\n        if (solve(row + 1)) return true;\r\n\r\n        // Backtrack\r\n        queens.pop();\r\n        node.status = \"visited\";\r\n        nodesToAnimate.push({node: {...node}, type: \"visited\"});\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  solve();\r\n  return nodesToAnimate;\r\n}"]},"metadata":{},"sourceType":"module"}