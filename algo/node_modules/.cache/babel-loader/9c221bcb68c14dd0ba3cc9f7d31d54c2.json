{"ast":null,"code":"export function nQueensAlgorithm(grid, size = 8) {\n  const boardSize = size;\n  const queens = [];\n  const nodesToAnimate = []; // Define it here\n  // Reset grid statuses\n\n  for (let row = 0; row < boardSize; row++) {\n    for (let col = 0; col < boardSize; col++) {\n      if (grid[row][col].status !== \"wall\") {\n        grid[row][col].status = \"unvisited\";\n      }\n    }\n  }\n\n  function isSafe(row, col) {\n    if (grid[row][col].status === \"wall\") return false;\n\n    for (const [qRow, qCol] of queens) {\n      if (qCol === col || qRow - qCol === row - col || qRow + qCol === row + col) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function solve(row = 0) {\n    if (row === boardSize) return true;\n\n    for (let col = 0; col < boardSize; col++) {\n      if (isSafe(row, col)) {\n        queens.push([row, col]);\n        const node = grid[row][col];\n        node.status = \"queen\";\n        nodesToAnimate.push(node); // Add to animation queue\n\n        if (solve(row + 1)) return true; // Backtrack\n\n        queens.pop();\n        node.status = \"visited\";\n        nodesToAnimate.push(node); // Add backtrack step\n      }\n    }\n\n    return false;\n  }\n\n  solve();\n  return {\n    success: queens.length === boardSize,\n    animations: nodesToAnimate\n  };\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/nQueens.js"],"names":["nQueensAlgorithm","grid","size","boardSize","queens","nodesToAnimate","row","col","status","isSafe","qRow","qCol","solve","push","node","pop","success","length","animations"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAI,GAAG,CAAvC,EAA0C;AAC/C,QAAMC,SAAS,GAAGD,IAAlB;AACA,QAAME,MAAM,GAAG,EAAf;AACA,QAAMC,cAAc,GAAG,EAAvB,CAH+C,CAGpB;AAE3B;;AACA,OAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,SAAxB,EAAmCG,GAAG,EAAtC,EAA0C;AACxC,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,SAAxB,EAAmCI,GAAG,EAAtC,EAA0C;AACxC,UAAIN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC;AACpCP,QAAAA,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,GAAwB,WAAxB;AACD;AACF;AACF;;AAED,WAASC,MAAT,CAAgBH,GAAhB,EAAqBC,GAArB,EAA0B;AACxB,QAAIN,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,EAAeC,MAAf,KAA0B,MAA9B,EAAsC,OAAO,KAAP;;AAEtC,SAAK,MAAM,CAACE,IAAD,EAAOC,IAAP,CAAX,IAA2BP,MAA3B,EAAmC;AACjC,UAAIO,IAAI,KAAKJ,GAAT,IAAgBG,IAAI,GAAGC,IAAP,KAAgBL,GAAG,GAAGC,GAAtC,IAA6CG,IAAI,GAAGC,IAAP,KAAgBL,GAAG,GAAGC,GAAvE,EAA4E;AAC1E,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAED,WAASK,KAAT,CAAeN,GAAG,GAAG,CAArB,EAAwB;AACtB,QAAIA,GAAG,KAAKH,SAAZ,EAAuB,OAAO,IAAP;;AAEvB,SAAK,IAAII,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,SAAxB,EAAmCI,GAAG,EAAtC,EAA0C;AACxC,UAAIE,MAAM,CAACH,GAAD,EAAMC,GAAN,CAAV,EAAsB;AACpBH,QAAAA,MAAM,CAACS,IAAP,CAAY,CAACP,GAAD,EAAMC,GAAN,CAAZ;AACA,cAAMO,IAAI,GAAGb,IAAI,CAACK,GAAD,CAAJ,CAAUC,GAAV,CAAb;AACAO,QAAAA,IAAI,CAACN,MAAL,GAAc,OAAd;AACAH,QAAAA,cAAc,CAACQ,IAAf,CAAoBC,IAApB,EAJoB,CAIO;;AAE3B,YAAIF,KAAK,CAACN,GAAG,GAAG,CAAP,CAAT,EAAoB,OAAO,IAAP,CANA,CAQpB;;AACAF,QAAAA,MAAM,CAACW,GAAP;AACAD,QAAAA,IAAI,CAACN,MAAL,GAAc,SAAd;AACAH,QAAAA,cAAc,CAACQ,IAAf,CAAoBC,IAApB,EAXoB,CAWO;AAC5B;AACF;;AACD,WAAO,KAAP;AACD;;AAEDF,EAAAA,KAAK;AACL,SAAO;AAAEI,IAAAA,OAAO,EAAEZ,MAAM,CAACa,MAAP,KAAkBd,SAA7B;AAAwCe,IAAAA,UAAU,EAAEb;AAApD,GAAP;AACD","sourcesContent":["export function nQueensAlgorithm(grid, size = 8) {\r\n  const boardSize = size;\r\n  const queens = [];\r\n  const nodesToAnimate = []; // Define it here\r\n  \r\n  // Reset grid statuses\r\n  for (let row = 0; row < boardSize; row++) {\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (grid[row][col].status !== \"wall\") {\r\n        grid[row][col].status = \"unvisited\";\r\n      }\r\n    }\r\n  }\r\n\r\n  function isSafe(row, col) {\r\n    if (grid[row][col].status === \"wall\") return false;\r\n    \r\n    for (const [qRow, qCol] of queens) {\r\n      if (qCol === col || qRow - qCol === row - col || qRow + qCol === row + col) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function solve(row = 0) {\r\n    if (row === boardSize) return true;\r\n\r\n    for (let col = 0; col < boardSize; col++) {\r\n      if (isSafe(row, col)) {\r\n        queens.push([row, col]);\r\n        const node = grid[row][col];\r\n        node.status = \"queen\";\r\n        nodesToAnimate.push(node); // Add to animation queue\r\n        \r\n        if (solve(row + 1)) return true;\r\n\r\n        // Backtrack\r\n        queens.pop();\r\n        node.status = \"visited\";\r\n        nodesToAnimate.push(node); // Add backtrack step\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  solve();\r\n  return { success: queens.length === boardSize, animations: nodesToAnimate };\r\n}"]},"metadata":{},"sourceType":"module"}