{"ast":null,"code":"import TWEEN from \"@tweenjs/tween.js\";\nexport function getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    nodes.push(...row);\n  }\n\n  return nodes;\n} // Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode; //Excluding finish node\n\n  if (currentNode.previousNode !== null) {\n    currentNode = currentNode.previousNode;\n  }\n\n  while (currentNode !== null) {\n    // Excluding start node\n    if (currentNode.previousNode === null) {\n      break;\n    }\n\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}\nexport async function tweenToColor(node, geometry, colors, duration = 300, options) {\n  for (let i = 0; i < colors.length; i++) {\n    //console.log(node);\n    new TWEEN.Tween(node.faces[1].color).to(colors[i], duration).onUpdate(() => {\n      geometry.colorsNeedUpdate = true;\n    }).delay(i * 200).start();\n    new TWEEN.Tween(node.faces[2].color).to(colors[i], duration).onUpdate(() => {\n      geometry.colorsNeedUpdate = true;\n    }).delay(i * 200).start();\n  }\n\n  if (options) {\n    if (options.position) {\n      var facesIndices = [\"a\", \"b\", \"c\"];\n      facesIndices.forEach(function (indices) {\n        new TWEEN.Tween(geometry.vertices[node.faces[1][indices]]).to({\n          y: 0.5\n        }, duration).onUpdate(() => {\n          geometry.verticesNeedUpdate = true;\n        }).start();\n        new TWEEN.Tween(geometry.vertices[node.faces[2][indices]]).to({\n          y: 0.5\n        }, duration).onUpdate(() => {\n          geometry.verticesNeedUpdate = true;\n        }).start();\n      });\n      facesIndices.forEach(function (indices) {\n        new TWEEN.Tween(geometry.vertices[node.faces[1][indices]]).to({\n          y: 0\n        }, duration).onUpdate(() => {\n          geometry.verticesNeedUpdate = true;\n        }).delay(100).start();\n        new TWEEN.Tween(geometry.vertices[node.faces[2][indices]]).to({\n          y: 0\n        }, duration).onUpdate(() => {\n          geometry.verticesNeedUpdate = true;\n        }).delay(100).start();\n      });\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/helpers.js"],"names":["TWEEN","getAllNodes","grid","nodes","row","push","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","previousNode","unshift","tweenToColor","node","geometry","colors","duration","options","i","length","Tween","faces","color","to","onUpdate","colorsNeedUpdate","delay","start","position","facesIndices","forEach","indices","vertices","y","verticesNeedUpdate"],"mappings":"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","sourcesContent":["import TWEEN from \"@tweenjs/tween.js\";\r\n\r\nexport function getAllNodes(grid) {\r\n\tconst nodes = [];\r\n\tfor (const row of grid) {\r\n\t\tnodes.push(...row);\r\n\t}\r\n\treturn nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n\tconst nodesInShortestPathOrder = [];\r\n\tlet currentNode = finishNode;\r\n\t//Excluding finish node\r\n\tif(currentNode.previousNode !== null) {\r\n\t\tcurrentNode = currentNode.previousNode;\r\n\t}\r\n\twhile (currentNode !== null) {\r\n\t\t// Excluding start node\r\n\t\tif(currentNode.previousNode === null) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tnodesInShortestPathOrder.unshift(currentNode);\r\n\t\tcurrentNode = currentNode.previousNode;\r\n\t}\r\n\r\n\treturn nodesInShortestPathOrder;\r\n}\r\n\r\nexport async function tweenToColor(node, geometry, colors, duration = 300, options) {\r\n\tfor(let i=0; i<colors.length; i++) {\r\n\t\t//console.log(node);\r\n\t\tnew TWEEN.Tween(node.faces[1].color)\r\n\t\t\t.to(colors[i], duration)\r\n\t\t\t.onUpdate(() => {\r\n\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t})\r\n\t\t\t.delay(i*200)\r\n\t\t\t.start();\r\n\t\tnew TWEEN.Tween(node.faces[2].color)\r\n\t\t\t.to(colors[i], duration)\r\n\t\t\t.onUpdate(() => {\r\n\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t})\r\n\t\t\t.delay(i*200)\r\n\t\t\t.start();\r\n\t}\r\n\tif (options) {\r\n\t\tif (options.position) {\r\n\t\t\tvar facesIndices = [\"a\", \"b\", \"c\"];\r\n\t\t\tfacesIndices.forEach(function (indices) {\r\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[1][indices]])\r\n\t\t\t\t\t.to({ y: 0.5 }, duration)\r\n\t\t\t\t\t.onUpdate(() => {\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.start();\r\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[2][indices]])\r\n\t\t\t\t\t.to({ y: 0.5 }, duration)\r\n\t\t\t\t\t.onUpdate(() => {\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.start();\r\n\t\t\t});\r\n\t\t\tfacesIndices.forEach(function (indices) {\r\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[1][indices]])\r\n\t\t\t\t\t.to({ y: 0 }, duration)\r\n\t\t\t\t\t.onUpdate(() => {\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.delay(100)\r\n\t\t\t\t\t.start();\r\n\t\t\t\tnew TWEEN.Tween(geometry.vertices[node.faces[2][indices]])\r\n\t\t\t\t\t.to({ y: 0 }, duration)\r\n\t\t\t\t\t.onUpdate(() => {\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.delay(100)\r\n\t\t\t\t\t.start();\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}"]},"metadata":{},"sourceType":"module"}