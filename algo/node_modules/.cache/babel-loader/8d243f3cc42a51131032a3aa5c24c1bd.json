{"ast":null,"code":"export function unweightedSearchAlgorithm(grid, start, target, nodesToAnimate, name) {\n  let structure = [start];\n  let exploredNodes = {\n    start: true\n  };\n\n  while (structure.length) {\n    let currentNode = name === \"BFS\" ? structure.shift() : structure.pop();\n    nodesToAnimate.push(currentNode);\n    if (name === \"DFS\") exploredNodes[currentNode.id] = true;\n    currentNode.status = \"visited\"; // Ending condition\n\n    if (currentNode.id === target.id) return \"success!\"; // Update neighbors\n\n    let currentNeighbors = getNeighbors(currentNode, grid, name);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor.id]) {\n        if (name === \"BFS\") exploredNodes[neighbor.id] = true;\n\n        if (neighbor.id !== start.id) {\n          neighbor.previousNode = currentNode;\n        }\n\n        structure.push(neighbor);\n      }\n    });\n  }\n\n  return false;\n}\n\nfunction getNeighbors(node, grid, name) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  let neighbor;\n\n  if (row > 0) {\n    neighbor = grid[row - 1][col];\n\n    if (name === \"BFS\") {\n      neighbors.push(neighbor);\n    } else {\n      neighbors.unshift(neighbor);\n    }\n  }\n\n  if (row < grid.length - 1) {\n    neighbor = grid[row + 1][col];\n\n    if (name === \"BFS\") {\n      neighbors.push(neighbor);\n    } else {\n      neighbors.unshift(neighbor);\n    }\n  }\n\n  if (col > 0) {\n    neighbor = grid[row][col - 1];\n\n    if (name === \"BFS\") {\n      neighbors.push(neighbor);\n    } else {\n      neighbors.unshift(neighbor);\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    neighbor = grid[row][col + 1];\n\n    if (name === \"BFS\") {\n      neighbors.push(neighbor);\n    } else {\n      neighbors.unshift(neighbor);\n    }\n  }\n\n  return neighbors.filter(neighbor => neighbor.stutus !== \"visited\");\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/unweightedSearchAlgorithm.js"],"names":["unweightedSearchAlgorithm","grid","start","target","nodesToAnimate","name","structure","exploredNodes","length","currentNode","shift","pop","push","id","status","currentNeighbors","getNeighbors","forEach","neighbor","previousNode","node","neighbors","col","row","unshift","filter","stutus"],"mappings":"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","sourcesContent":["export function unweightedSearchAlgorithm(grid, start, target, nodesToAnimate, name) {\r\n    let structure = [start];\r\n    let exploredNodes = {start: true};\r\n    while (structure.length) {\r\n      let currentNode = name === \"BFS\" ? structure.shift() : structure.pop();\r\n      nodesToAnimate.push(currentNode);\r\n      if (name === \"DFS\") exploredNodes[currentNode.id] = true;\r\n          currentNode.status = \"visited\";\r\n          // Ending condition\r\n          if (currentNode.id === target.id) return \"success!\";\r\n          // Update neighbors\r\n      let currentNeighbors = getNeighbors(currentNode, grid, name);\r\n      currentNeighbors.forEach(neighbor => {\r\n        if (!exploredNodes[neighbor.id]) {\r\n          if (name === \"BFS\") exploredNodes[neighbor.id] = true;\r\n                  if(neighbor.id !== start.id) {\r\n                      neighbor.previousNode = currentNode;\r\n                  }\r\n          structure.push(neighbor);\r\n        }\r\n          });\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  function getNeighbors(node, grid, name) {\r\n      const neighbors = [];\r\n      const {col, row} = node;\r\n      let neighbor;\r\n      if (row > 0) {\r\n          neighbor = grid[row - 1][col];\r\n          if (name === \"BFS\") {\r\n              neighbors.push(neighbor);\r\n          } else {\r\n              neighbors.unshift(neighbor);\r\n          }\r\n      }\r\n      if (row < grid.length - 1) {\r\n          neighbor = grid[row + 1][col];\r\n          if (name === \"BFS\") {\r\n              neighbors.push(neighbor);\r\n          } else {\r\n              neighbors.unshift(neighbor);\r\n          }\r\n      }\r\n      if (col > 0) {\r\n          neighbor = grid[row][col - 1];\r\n          if (name === \"BFS\") {\r\n              neighbors.push(neighbor);\r\n          } else {\r\n              neighbors.unshift(neighbor);\r\n          }\r\n      }\r\n      if (col < grid[0].length - 1) {\r\n          neighbor = grid[row][col + 1];\r\n          if (name === \"BFS\") {\r\n              neighbors.push(neighbor);\r\n          } else {\r\n              neighbors.unshift(neighbor);\r\n          }\r\n      }\r\n      return neighbors.filter(neighbor => neighbor.stutus !== \"visited\");\r\n  }"]},"metadata":{},"sourceType":"module"}