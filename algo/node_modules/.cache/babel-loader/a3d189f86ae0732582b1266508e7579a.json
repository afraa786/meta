{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"C:\\\\Users\\\\Afraa\\\\Documents\\\\3D-Pathfinding-Visualizer\\\\src\\\\components\\\\Grid.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useRef, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\nimport img from './floor_texture.jpg';\nimport { tweenToColor, getNodesInShortestPathOrder } from './algorithms/helpers';\nimport TWEEN from '@tweenjs/tween.js';\nimport { weightedSearchAlgorithm } from \"./algorithms/weightedSearchAlgorithm.js\";\nimport { unweightedSearchAlgorithm } from \"./algorithms/unweightedSearchAlgorithm.js\";\nimport { randomMaze, recursiveDivisionMaze } from './algorithms/mazeAlgorithms';\nimport { nQueensAlgorithm } from './algorithms/nQueens.js';\nimport { useThree } from 'react-three-fiber';\n\nfunction Grid(props) {\n  _s();\n\n  let groundMaterial;\n  let groundMesh;\n  let mouseDownX = 0;\n  let mouseDownY = 0;\n  let previousHoverNodeId;\n  let currentHoverNodeId;\n  let mouseIsUp = true;\n  const [groundGeometry, setGroundGeometry] = useState(new THREE.PlaneGeometry(300, 300, 30, 30));\n  const selectedAlgorithm = props.selectedAlgorithm;\n  const selectedMazeAlgorithm = props.selectedMazeAlgorithm;\n  const runState = props.worldProperties.runState;\n  const trainTheAgent = props.worldProperties.trainAgent;\n  const clearTheWalls = props.worldProperties.clearWalls;\n  const clearThePath = props.worldProperties.clearPath;\n  const algorithmSpeed = props.algorithmSpeed;\n  const agentKnowledge = props.agentKnowledge;\n  const applyingSettings = props.applyingSettings;\n  const visualizeThePolicy = props.visualizeOptimalPolicy;\n  const {\n    camera\n  } = useThree();\n  useEffect(() => {\n    if (props.applyingSettings) {\n      resetTerrainConfig();\n    }\n\n    if (props.visualizeOptimalPolicy) {\n      calculateOptimalPolicy();\n      animateOptimalPolicy();\n      props.finishedOptimalPolicy();\n    }\n  }, [applyingSettings, visualizeThePolicy]);\n  useEffect(() => {\n    if (props.agentKnowledge === \"clearMemory\") {\n      terrain.records = [];\n      terrain.q_table = Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0));\n      props.agentResetDone();\n    }\n\n    if (props.worldProperties.runState === true) {\n      if (props.selectedAlgorithm.type === \"machine-learning\") {\n        animateQlearning();\n      } else {\n        visualizeAlgorithm();\n      }\n    } else if (props.worldProperties.clearWalls === true) {\n      clearWalls();\n    } else if (props.worldProperties.clearPath === true) {\n      clearPath();\n    } else if (props.worldProperties.trainAgent === true) {\n      qLearning();\n    } else if (props.selectedMazeAlgorithm === \"randomMaze\") {\n      clearPath();\n      let nodesToAnimate = [];\n      randomMaze(terrain.grid, nodesToAnimate, \"wall\");\n      animateMaze(nodesToAnimate, \"wall\", 30);\n    } else if (props.selectedMazeAlgorithm === \"recursiveDivision\") {\n      clearPath();\n      let nodesToAnimate = [];\n      recursiveDivisionMaze(terrain.grid, 2, terrain.grid.length - 3, 2, terrain.grid.length - 3, \"horizontal\", false, nodesToAnimate, \"wall\");\n      animateMaze(nodesToAnimate, \"wall\", 30);\n    }\n  }, [runState, clearTheWalls, clearThePath, selectedMazeAlgorithm, trainTheAgent, agentKnowledge]);\n  const loader = useMemo(() => new THREE.TextureLoader().load(img, function (texture) {\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n    texture.repeat.x = 30;\n    texture.repeat.y = 30;\n    groundMaterial = new THREE.MeshLambertMaterial({\n      map: texture,\n      side: THREE.FrontSide,\n      vertexColors: THREE.FaceColors\n    });\n    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);\n    groundMesh.receiveShadow = true;\n  }), [img]);\n  groundMaterial = new THREE.MeshLambertMaterial({\n    map: loader,\n    side: THREE.FrontSide,\n    vertexColors: THREE.FaceColors\n  });\n  const mesh = useRef(null);\n  const [terrain, setTerrain] = useState({\n    grid: initializeGrid(),\n    states: initStates(),\n    q_table: Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)),\n    records: [],\n    optimalPolicy: [],\n    actions: {\n      \"left\": [0, -1],\n      \"down\": [1, 0],\n      \"right\": [0, 1],\n      \"up\": [-1, 0]\n    },\n    discountFactor: 0.8,\n    alpha: 0.1,\n    start: [props.settingsConfig.startRow, props.settingsConfig.startCol],\n    finish: [props.settingsConfig.finishRow, props.settingsConfig.finishCol]\n  });\n\n  function initializeGrid() {\n    let tempGrid = [];\n\n    for (let i = 0; i < 30; i++) {\n      let currentRow = [];\n\n      for (let j = 0; j < 30; j++) {\n        let node = createNode(i, j);\n        currentRow.push(node);\n      }\n\n      tempGrid.push(currentRow);\n    }\n\n    renderLoop();\n    return tempGrid;\n  }\n\n  function createNode(row, col) {\n    let status = \"default\";\n    let faces = {};\n    let faceIndex = row * 2 * props.worldProperties.cols + col * 2;\n    faces[1] = groundGeometry.faces[faceIndex];\n    faceIndex = faceIndex % 2 === 0 ? faceIndex + 1 : faceIndex - 1;\n    faces[2] = groundGeometry.faces[faceIndex];\n\n    if (row === props.worldProperties.start.row && col === props.worldProperties.start.col) {\n      status = \"start\";\n    } else if (row === props.worldProperties.finish.row && col === props.worldProperties.finish.col) {\n      status = \"finish\";\n    }\n\n    let node = {\n      id: row * props.worldProperties.cols + col,\n      row: row,\n      col: col,\n      faces: faces,\n      status: status,\n      distance: Infinity,\n      totalDistance: Infinity,\n      heuristicDistance: null,\n      direction: null,\n      weight: 0,\n      qValue: 0,\n      reward: 0,\n      visits: 0,\n      onceSpecial: false,\n      previousNode: null\n    };\n\n    if (status === \"start\") {\n      node.onceSpecial = true;\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.start]);\n    } else if (status === \"finish\") {\n      node.reward = 100;\n      node.onceSpecial = true;\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.finish]);\n    }\n\n    return node;\n  }\n\n  function initStates() {\n    let tempStateGrid = [];\n\n    for (let row = 0; row < props.worldProperties.rows; row++) {\n      for (let col = 0; col < props.worldProperties.cols; col++) {\n        tempStateGrid.push([row, col]);\n      }\n    }\n\n    return tempStateGrid;\n  }\n\n  function renderLoop() {\n    window.requestAnimationFrame(renderLoop);\n    hoverLoop();\n    TWEEN.update();\n  }\n\n  function hoverLoop() {\n    if (mouseIsUp || currentHoverNodeId === previousHoverNodeId) return;\n    previousHoverNodeId = currentHoverNodeId;\n    let nodeRow = Math.floor(currentHoverNodeId / props.worldProperties.rows);\n    let nodeCol = currentHoverNodeId % props.worldProperties.cols;\n\n    if (nodeRow === props.worldProperties.start.row && nodeCol === props.worldProperties.start.col || nodeRow === props.worldProperties.finish.row && nodeCol === props.worldProperties.finish.col) {\n      return;\n    } else if (terrain.grid[nodeRow][nodeCol].status === \"wall\") {\n      terrain.grid[nodeRow][nodeCol].status = \"default\";\n      terrain.grid[nodeRow][nodeCol].reward = 0;\n      terrain.grid[nodeRow][nodeCol].visits = 0;\n      tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.default]);\n    } else {\n      terrain.grid[nodeRow][nodeCol].status = \"wall\";\n      terrain.grid[nodeRow][nodeCol].visits = -1;\n      terrain.grid[nodeRow][nodeCol].reward = -100;\n      tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n    }\n  }\n\n  function mouseUpHandler(event) {\n    if (mouseDownX !== event.clientX || mouseDownY !== event.clientY) return;\n    let nodeId = findNodeId(event.faceIndex);\n\n    if (nodeId.nodeRow === props.worldProperties.start.row && nodeId.nodeCol === props.worldProperties.start.col || nodeId.nodeRow === props.worldProperties.finish.row && nodeId.nodeCol === props.worldProperties.finish.col) {\n      return;\n    } else if (terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status === \"wall\") {\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = 0;\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"default\";\n      tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.default]);\n    } else {\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = -100;\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"wall\";\n      tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\n    }\n  }\n\n  function findNodeId(faceIndex) {\n    let linearIndex = Math.floor(faceIndex / 2);\n    return {\n      nodeRow: Math.floor(linearIndex / props.worldProperties.rows),\n      nodeCol: linearIndex % props.worldProperties.cols\n    };\n  }\n\n  function mouseDownHandler(event) {\n    mouseDownX = event.clientX;\n    mouseDownY = event.clientY;\n  }\n\n  function visualizeAlgorithm() {\n    console.log(\"Visualizing algorithm:\", selectedAlgorithm.algorithm);\n    clearPath();\n    let nodesToAnimate = [];\n    let processedSuccessfully;\n    const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\n    const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\n\n    if (selectedAlgorithm.type === \"weighted\") {\n      processedSuccessfully = weightedSearchAlgorithm(terrain.grid, startNode, finishNode, nodesToAnimate, selectedAlgorithm.algorithm, selectedAlgorithm.heuristic);\n    } else if (selectedAlgorithm.type === \"unweighted\") {\n      processedSuccessfully = unweightedSearchAlgorithm(terrain.grid, startNode, finishNode, nodesToAnimate, selectedAlgorithm.algorithm);\n    } else if (selectedAlgorithm.algorithm === \"nQueens\") {\n      processedSuccessfully = nQueensAlgorithm(terrain.grid, nodesToAnimate, props.worldProperties.gridSize || 8);\n      animateAlgorithm(nodesToAnimate, [], algorithmSpeed);\n      props.updateRunState(false);\n      return;\n    }\n\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateAlgorithm(nodesToAnimate, nodesInShortestPathOrder, algorithmSpeed);\n  }\n\n  function animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, timerDelay) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder, 5 * timerDelay);\n        }, timerDelay * i);\n        return;\n      }\n\n      if (visitedNodesInOrder[i].row === props.worldProperties.start.row && visitedNodesInOrder[i].col === props.worldProperties.start.col || visitedNodesInOrder[i].row === props.worldProperties.finish.row && visitedNodesInOrder[i].col === props.worldProperties.finish.col) {\n        continue;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (!node) return;\n        tweenToColor(node, groundGeometry, [{\n          r: 1.0,\n          g: 0.321,\n          b: 0.784\n        }, props.worldProperties.colors.visited], 300, {\n          position: false\n        });\n      }, timerDelay * i);\n    }\n  }\n\n  function animateShortestPath(nodesInShortestPathOrder, timerDelay) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.path], undefined, {\n          position: false\n        });\n\n        if (i === nodesInShortestPathOrder.length - 1) {\n          props.updateRunState(false);\n        }\n      }, timerDelay * i);\n    }\n  } // ... [Rest of your existing functions remain unchanged] ...\n\n\n  return /*#__PURE__*/_jsxDEV(\"mesh\", {\n    ref: mesh,\n    position: [0, 0, 0],\n    children: [/*#__PURE__*/_jsxDEV(\"gridHelper\", {\n      args: [300, props.gridDimensions, 0x5c78bd, 0x5c78bd]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"mesh\", {\n      rotation: [-Math.PI / 2, 0, 0],\n      position: [0, -0.1, 0],\n      receiveShadow: true,\n      onPointerDown: e => {\n        mouseIsUp = false;\n        mouseDownHandler(e);\n      },\n      onPointerUp: e => {\n        if (props.resetStatus === true || mouseIsUp === true) {\n          mouseIsUp = true;\n        }\n\n        mouseUpHandler(e);\n      },\n      onPointerMove: e => {\n        if (mouseIsUp === true || props.resetStatus === false) {\n          return;\n        } else if (mouseIsUp === false) {\n          currentHoverNodeId = Math.floor(e.faceIndex / 2);\n          return;\n        }\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"primitive\", {\n        attach: \"geometry\",\n        object: groundGeometry\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 375,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"primitive\", {\n        attach: \"material\",\n        object: groundMaterial\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 376,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 351,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"axesHelper\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 378,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 349,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Grid, \"mwqKjoPnyBuqrmUpKA7fzqMxY08=\", false, function () {\n  return [useThree];\n});\n\n_c = Grid;\nexport default Grid;\n\nvar _c;\n\n$RefreshReg$(_c, \"Grid\");","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/Grid.js"],"names":["React","useState","useRef","useEffect","useMemo","THREE","img","tweenToColor","getNodesInShortestPathOrder","TWEEN","weightedSearchAlgorithm","unweightedSearchAlgorithm","randomMaze","recursiveDivisionMaze","nQueensAlgorithm","useThree","Grid","props","groundMaterial","groundMesh","mouseDownX","mouseDownY","previousHoverNodeId","currentHoverNodeId","mouseIsUp","groundGeometry","setGroundGeometry","PlaneGeometry","selectedAlgorithm","selectedMazeAlgorithm","runState","worldProperties","trainTheAgent","trainAgent","clearTheWalls","clearWalls","clearThePath","clearPath","algorithmSpeed","agentKnowledge","applyingSettings","visualizeThePolicy","visualizeOptimalPolicy","camera","resetTerrainConfig","calculateOptimalPolicy","animateOptimalPolicy","finishedOptimalPolicy","terrain","records","q_table","Array","rows","fill","map","cols","agentResetDone","type","animateQlearning","visualizeAlgorithm","qLearning","nodesToAnimate","grid","animateMaze","length","loader","TextureLoader","load","texture","wrapS","RepeatWrapping","wrapT","repeat","x","y","MeshLambertMaterial","side","FrontSide","vertexColors","FaceColors","Mesh","receiveShadow","mesh","setTerrain","initializeGrid","states","initStates","optimalPolicy","actions","discountFactor","alpha","start","settingsConfig","startRow","startCol","finish","finishRow","finishCol","tempGrid","i","currentRow","j","node","createNode","push","renderLoop","row","col","status","faces","faceIndex","id","distance","Infinity","totalDistance","heuristicDistance","direction","weight","qValue","reward","visits","onceSpecial","previousNode","colors","tempStateGrid","window","requestAnimationFrame","hoverLoop","update","nodeRow","Math","floor","nodeCol","default","wall","mouseUpHandler","event","clientX","clientY","nodeId","findNodeId","linearIndex","mouseDownHandler","console","log","algorithm","processedSuccessfully","startNode","finishNode","heuristic","gridSize","animateAlgorithm","updateRunState","nodesInShortestPathOrder","visitedNodesInOrder","timerDelay","setTimeout","animateShortestPath","r","g","b","visited","position","path","undefined","gridDimensions","PI","e","resetStatus"],"mappings":"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","sourcesContent":["import React, { useState, useRef, useEffect, useMemo } from 'react';\r\nimport * as THREE from 'three';\r\nimport img from './floor_texture.jpg';\r\nimport { tweenToColor, getNodesInShortestPathOrder } from './algorithms/helpers';\r\nimport TWEEN from '@tweenjs/tween.js';\r\nimport { weightedSearchAlgorithm } from \"./algorithms/weightedSearchAlgorithm.js\";\r\nimport { unweightedSearchAlgorithm } from \"./algorithms/unweightedSearchAlgorithm.js\";\r\nimport { randomMaze, recursiveDivisionMaze } from './algorithms/mazeAlgorithms';\r\nimport { nQueensAlgorithm } from './algorithms/nQueens.js';\r\nimport { useThree } from 'react-three-fiber';\r\n\r\nfunction Grid(props) {\r\n  let groundMaterial;\r\n  let groundMesh;\r\n  let mouseDownX = 0;\r\n  let mouseDownY = 0;\r\n  let previousHoverNodeId;\r\n  let currentHoverNodeId;\r\n  let mouseIsUp = true;\r\n  \r\n  const [groundGeometry, setGroundGeometry] = useState(new THREE.PlaneGeometry(300,300,30,30));\r\n  \r\n  const selectedAlgorithm = props.selectedAlgorithm;\r\n  const selectedMazeAlgorithm = props.selectedMazeAlgorithm;\r\n  const runState = props.worldProperties.runState;\r\n  const trainTheAgent = props.worldProperties.trainAgent;\r\n  const clearTheWalls = props.worldProperties.clearWalls;\r\n  const clearThePath = props.worldProperties.clearPath;\r\n  const algorithmSpeed = props.algorithmSpeed;\r\n  const agentKnowledge = props.agentKnowledge;\r\n  const applyingSettings = props.applyingSettings;\r\n  const visualizeThePolicy = props.visualizeOptimalPolicy;\r\n  \r\n  const { camera } = useThree();\r\n\r\n  useEffect(() => {\r\n    if(props.applyingSettings){\r\n      resetTerrainConfig();\r\n    }\r\n    if(props.visualizeOptimalPolicy){\r\n      calculateOptimalPolicy();\r\n      animateOptimalPolicy();\r\n      props.finishedOptimalPolicy();\r\n    }\r\n  },[applyingSettings, visualizeThePolicy]);\r\n\r\n  useEffect(() => {\r\n    if(props.agentKnowledge ===\"clearMemory\"){\r\n      terrain.records = [];\r\n      terrain.q_table = Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0));\r\n      props.agentResetDone();\r\n    }\r\n    if(props.worldProperties.runState === true){\r\n      if(props.selectedAlgorithm.type === \"machine-learning\"){\r\n        animateQlearning()\r\n      }\r\n      else{\r\n        visualizeAlgorithm();\r\n      }\r\n    }\r\n    else if(props.worldProperties.clearWalls === true){\r\n      clearWalls();\r\n    }\r\n    else if(props.worldProperties.clearPath === true){\r\n      clearPath();\r\n    }\r\n    else if(props.worldProperties.trainAgent === true){\r\n      qLearning();\r\n    }\r\n    else if(props.selectedMazeAlgorithm === \"randomMaze\"){\r\n      clearPath();\r\n      let nodesToAnimate = [];\r\n      randomMaze(terrain.grid, nodesToAnimate, \"wall\");\r\n      animateMaze(nodesToAnimate, \"wall\", 30);\r\n    }\r\n    else if(props.selectedMazeAlgorithm === \"recursiveDivision\"){\r\n      clearPath();\r\n      let nodesToAnimate = [];\r\n      recursiveDivisionMaze(\r\n        terrain.grid, \r\n        2, \r\n        terrain.grid.length - 3,\r\n        2, \r\n        terrain.grid.length - 3, \r\n        \"horizontal\",\r\n        false,\r\n        nodesToAnimate,\r\n        \"wall\");\r\n      animateMaze(nodesToAnimate, \"wall\", 30)\r\n    }\r\n  }, [runState, clearTheWalls, clearThePath, selectedMazeAlgorithm, trainTheAgent, agentKnowledge]);\r\n\r\n  const loader = useMemo(() => new THREE.TextureLoader().load(img, function(texture){\r\n    texture.wrapS = THREE.RepeatWrapping;\r\n    texture.wrapT = THREE.RepeatWrapping;\r\n    texture.repeat.x = 30;\r\n    texture.repeat.y = 30;\r\n    groundMaterial = new THREE.MeshLambertMaterial({\r\n      map: texture,\r\n      side: THREE.FrontSide,\r\n      vertexColors: THREE.FaceColors,\r\n    });\r\n    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);\r\n    groundMesh.receiveShadow = true;\r\n  }), [img]);\r\n\r\n  groundMaterial = new THREE.MeshLambertMaterial({\r\n    map: loader,\r\n    side: THREE.FrontSide,\r\n    vertexColors: THREE.FaceColors,\r\n  });\r\n\r\n  const mesh = useRef(null);\r\n  \r\n  const [terrain, setTerrain] = useState({\r\n    grid: initializeGrid(),\r\n    states: initStates(),\r\n    q_table: Array(props.worldProperties.rows).fill().map(() => Array(props.worldProperties.cols).fill(0)),\r\n    records: [],\r\n    optimalPolicy: [],\r\n    actions: { \"left\":[0,-1], \"down\":[1,0],\"right\":[0,1], \"up\":[-1,0]},\r\n    discountFactor: 0.8,\r\n    alpha: 0.1,\r\n    start: [props.settingsConfig.startRow,props.settingsConfig.startCol],\r\n    finish: [props.settingsConfig.finishRow,props.settingsConfig.finishCol]\r\n  });\r\n\r\n  function initializeGrid(){\r\n    let tempGrid = []\r\n    for(let i = 0; i < 30; i++){\r\n      let currentRow = [];\r\n      for(let j = 0; j < 30; j++){\r\n        let node = createNode(i, j);\r\n        currentRow.push(node);\r\n      }\r\n      tempGrid.push(currentRow);\r\n    }\r\n    renderLoop();\r\n    return tempGrid;\r\n  }   \r\n\r\n  function createNode(row, col){\r\n    let status = \"default\";\r\n    let faces = {};\r\n    let faceIndex = row * 2 * props.worldProperties.cols + col * 2;\r\n    faces[1] = groundGeometry.faces[faceIndex];\r\n    faceIndex = faceIndex % 2 === 0 ? faceIndex + 1 : faceIndex - 1;\r\n    faces[2] = groundGeometry.faces[faceIndex];\r\n\r\n    if(row === props.worldProperties.start.row && col === props.worldProperties.start.col){\r\n      status = \"start\";\r\n    }\r\n    else if(row === props.worldProperties.finish.row && col === props.worldProperties.finish.col){\r\n      status = \"finish\";\r\n    }\r\n    \r\n    let node = {\r\n      id: row * props.worldProperties.cols + col,\r\n      row: row,\r\n      col: col,\r\n      faces: faces,\r\n      status: status,\r\n      distance: Infinity,\r\n      totalDistance: Infinity,\r\n      heuristicDistance: null,\r\n      direction: null,\r\n      weight: 0,\r\n      qValue: 0,\r\n      reward: 0,\r\n      visits: 0,\r\n      onceSpecial: false,\r\n      previousNode: null,\r\n    };\r\n    \r\n    if(status === \"start\"){\r\n      node.onceSpecial = true;\r\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.start]);\r\n    }\r\n    else if(status === \"finish\"){\r\n      node.reward = 100;\r\n      node.onceSpecial = true;\r\n      tweenToColor(node, groundGeometry, [props.worldProperties.colors.finish]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  function initStates(){\r\n    let tempStateGrid = [];\r\n    for(let row = 0; row < props.worldProperties.rows; row++){\r\n      for(let col = 0; col < props.worldProperties.cols; col++){\r\n        tempStateGrid.push([row,col]);\r\n      }\r\n    }\r\n    return tempStateGrid;\r\n  }\r\n\r\n  function renderLoop(){\r\n    window.requestAnimationFrame(renderLoop);\r\n    hoverLoop();\r\n    TWEEN.update();\r\n  }\r\n\r\n  function hoverLoop(){\r\n    if(mouseIsUp || currentHoverNodeId === previousHoverNodeId) return;\r\n    \r\n    previousHoverNodeId = currentHoverNodeId;\r\n    let nodeRow = Math.floor(currentHoverNodeId / props.worldProperties.rows);\r\n    let nodeCol = currentHoverNodeId % props.worldProperties.cols;\r\n    \r\n    if((nodeRow === props.worldProperties.start.row && nodeCol === props.worldProperties.start.col) || \r\n       (nodeRow === props.worldProperties.finish.row && nodeCol === props.worldProperties.finish.col)){\r\n      return;\r\n    }\r\n    else if(terrain.grid[nodeRow][nodeCol].status === \"wall\"){\r\n      terrain.grid[nodeRow][nodeCol].status = \"default\";\r\n      terrain.grid[nodeRow][nodeCol].reward = 0;\r\n      terrain.grid[nodeRow][nodeCol].visits = 0;\r\n      tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.default]);\r\n    }\r\n    else {\r\n      terrain.grid[nodeRow][nodeCol].status = \"wall\";\r\n      terrain.grid[nodeRow][nodeCol].visits = -1;\r\n      terrain.grid[nodeRow][nodeCol].reward = -100;\r\n      tweenToColor(terrain.grid[nodeRow][nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\r\n    }\r\n  }\r\n\r\n  function mouseUpHandler(event){\r\n    if((mouseDownX !== event.clientX) || (mouseDownY !== event.clientY)) return;\r\n    \r\n    let nodeId = findNodeId(event.faceIndex);\r\n    if((nodeId.nodeRow === props.worldProperties.start.row && nodeId.nodeCol === props.worldProperties.start.col) || \r\n       (nodeId.nodeRow === props.worldProperties.finish.row && nodeId.nodeCol === props.worldProperties.finish.col)){\r\n      return;\r\n    }\r\n    else if(terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status === \"wall\"){\r\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = 0;\r\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"default\";\r\n      tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.default]);\r\n    }\r\n    else {\r\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].reward = -100;\r\n      terrain.grid[nodeId.nodeRow][nodeId.nodeCol].status = \"wall\";\r\n      tweenToColor(terrain.grid[nodeId.nodeRow][nodeId.nodeCol], groundGeometry, [props.worldProperties.colors.wall]);\r\n    }\r\n  }\r\n    \r\n  function findNodeId(faceIndex){\r\n    let linearIndex = Math.floor(faceIndex / 2);\r\n    return {\r\n      nodeRow: Math.floor(linearIndex / props.worldProperties.rows),\r\n      nodeCol: linearIndex % props.worldProperties.cols,\r\n    }\r\n  }\r\n\r\n  function mouseDownHandler(event){\r\n    mouseDownX = event.clientX;\r\n    mouseDownY = event.clientY;\r\n  }\r\n\r\n  function visualizeAlgorithm() {\r\n    console.log(\"Visualizing algorithm:\", selectedAlgorithm.algorithm);\r\n    clearPath();\r\n    let nodesToAnimate = [];\r\n    let processedSuccessfully;\r\n    const startNode = terrain.grid[props.worldProperties.start.row][props.worldProperties.start.col];\r\n    const finishNode = terrain.grid[props.worldProperties.finish.row][props.worldProperties.finish.col];\r\n    \r\n    if (selectedAlgorithm.type === \"weighted\") {\r\n      processedSuccessfully = weightedSearchAlgorithm(\r\n        terrain.grid,\r\n        startNode,\r\n        finishNode,\r\n        nodesToAnimate,\r\n        selectedAlgorithm.algorithm,\r\n        selectedAlgorithm.heuristic,\r\n      );\r\n    }\r\n    else if (selectedAlgorithm.type === \"unweighted\") {\r\n      processedSuccessfully = unweightedSearchAlgorithm(\r\n        terrain.grid,\r\n        startNode,\r\n        finishNode,\r\n        nodesToAnimate,\r\n        selectedAlgorithm.algorithm,\r\n      );\r\n    }\r\n    else if (selectedAlgorithm.algorithm === \"nQueens\") {\r\n      processedSuccessfully = nQueensAlgorithm(\r\n        terrain.grid,\r\n        nodesToAnimate,\r\n        props.worldProperties.gridSize || 8\r\n      );\r\n      animateAlgorithm(nodesToAnimate, [], algorithmSpeed);\r\n      props.updateRunState(false);\r\n      return;\r\n    }\r\n\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    animateAlgorithm(nodesToAnimate, nodesInShortestPathOrder, algorithmSpeed);\r\n  }\r\n\r\n  function animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder, timerDelay){\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          animateShortestPath(nodesInShortestPathOrder, 5 * timerDelay);\r\n        }, timerDelay * i);\r\n        return;\r\n      }\r\n      if ((visitedNodesInOrder[i].row === props.worldProperties.start.row &&\r\n          visitedNodesInOrder[i].col === props.worldProperties.start.col) ||\r\n          (visitedNodesInOrder[i].row === props.worldProperties.finish.row &&\r\n          visitedNodesInOrder[i].col === props.worldProperties.finish.col)\r\n      ) {\r\n        continue;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        if (!node) return;\r\n        tweenToColor(\r\n          node,\r\n          groundGeometry,\r\n          [{ r: 1.0, g: 0.321, b: 0.784 }, props.worldProperties.colors.visited],\r\n          300,\r\n          { position: false }\r\n        );\r\n      }, timerDelay * i);\r\n    }\r\n  }\r\n\r\n  function animateShortestPath(nodesInShortestPathOrder, timerDelay){\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        tweenToColor(node, groundGeometry, [props.worldProperties.colors.path], undefined, {\r\n          position: false,\r\n        });\r\n        if (i === nodesInShortestPathOrder.length - 1) {\r\n          props.updateRunState(false);\r\n        }\r\n      }, timerDelay * i);\r\n    }\r\n  }\r\n\r\n  // ... [Rest of your existing functions remain unchanged] ...\r\n\r\n  return (\r\n    <mesh ref={mesh} position={[0, 0, 0]}>\r\n      <gridHelper args={[300, props.gridDimensions, 0x5c78bd, 0x5c78bd]} />\r\n      <mesh \r\n        rotation={[-Math.PI / 2, 0, 0]} \r\n        position={[0, -0.1, 0]} \r\n        receiveShadow={true}\r\n        onPointerDown={(e) => {\r\n          mouseIsUp = false;\r\n          mouseDownHandler(e);\r\n        }}\r\n        onPointerUp={e => {\r\n          if (props.resetStatus === true || mouseIsUp === true) {\r\n            mouseIsUp = true;\r\n          }\r\n          mouseUpHandler(e);\r\n        }}\r\n        onPointerMove={e => {\r\n          if (mouseIsUp === true || props.resetStatus === false) {\r\n            return;\r\n          }\r\n          else if (mouseIsUp === false) {\r\n            currentHoverNodeId = Math.floor(e.faceIndex / 2);\r\n            return;\r\n          }\r\n        }}\r\n      >\r\n        <primitive attach='geometry' object={groundGeometry} />  \r\n        <primitive attach='material' object={groundMaterial} />   \r\n      </mesh>\r\n      <axesHelper />\r\n    </mesh>\r\n  );\r\n}\r\n\r\nexport default Grid;"]},"metadata":{},"sourceType":"module"}