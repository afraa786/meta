{"ast":null,"code":"import { getAllNodes } from './helpers.js';\nexport function weightedSearchAlgorithm(grid, start, target, nodesToAnimate, name, heuristic) {\n  // Initialze nodes\n  start.distance = 0;\n  start.direction = \"right\";\n\n  if (name === \"aStar\") {\n    start.totalDistance = 0;\n  } // Should be a Priority Queue\n\n\n  let unvisitedNodes = getAllNodes(grid);\n\n  while (unvisitedNodes.length) {\n    let currentNode = closestNode(unvisitedNodes, name);\n\n    while (currentNode.status === \"wall\" && unvisitedNodes.length) {\n      currentNode = closestNode(unvisitedNodes, name);\n    }\n\n    if (currentNode.distance === Infinity) return false;\n    nodesToAnimate.push(currentNode); //if(currentNode.status !== \"start\" && currentNode.status !== \"finish\"){\n\n    currentNode.status = \"visited\"; //}\n    // Ending condition\n\n    if (currentNode.id === target.id) return \"success!\"; // Updating neighbors\n\n    if (name === \"CLA\" || name === \"greedy\" || name === \"aStar\") {\n      updateNeighbors(grid, currentNode, start, target, name, heuristic);\n    } else if (name === \"Dijkstra\") {\n      updateNeighbors(grid, currentNode);\n    }\n  }\n}\n\nfunction closestNode(unvisitedNodes, name) {\n  let currentClosest, index;\n\n  for (let i = 0; i < unvisitedNodes.length; i++) {\n    if (name === \"aStar\") {\n      if (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\n        currentClosest = unvisitedNodes[i];\n        index = i;\n      } else if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\n        if (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\n          currentClosest = unvisitedNodes[i];\n          index = i;\n        }\n      }\n    } else {\n      if (!currentClosest || currentClosest.distance > unvisitedNodes[i].distance) {\n        currentClosest = unvisitedNodes[i];\n        index = i;\n      }\n    }\n  }\n\n  unvisitedNodes.splice(index, 1);\n  return currentClosest;\n}\n\nfunction updateNeighbors(grid, node, start, target, name, heuristic) {\n  let neighbors = getNeighbors(node, grid);\n\n  for (let neighbor of neighbors) {\n    if (target) {\n      updateNode(node, neighbor, start, target, name, heuristic);\n    } else {\n      updateNode(node, neighbor);\n    }\n  }\n}\n\nfunction updateNode(currentNode, targetNode, actualStartNode, actualTargetNode, name, heuristic) {\n  let distance = getDistance(currentNode, targetNode);\n  let distanceToCompare;\n\n  if (actualTargetNode && name === \"CLA\") {\n    let weight = targetNode.weight === 15 ? 15 : 1;\n\n    if (heuristic === \"manhattanDistance\") {\n      distanceToCompare = currentNode.distance + (distance[0] + weight) * manhattanDistance(targetNode, actualTargetNode);\n    } else if (heuristic === \"poweredManhattanDistance\") {\n      distanceToCompare = currentNode.distance + targetNode.weight + distance[0] + Math.pow(manhattanDistance(targetNode, actualTargetNode), 2);\n    } else if (heuristic === \"extraPoweredManhattanDistance\") {\n      distanceToCompare = currentNode.distance + (distance[0] + weight) * Math.pow(manhattanDistance(targetNode, actualTargetNode), 7);\n    }\n  } else if (actualTargetNode && name === \"greedy\") {\n    distanceToCompare = targetNode.weight + distance[0] + manhattanDistance(targetNode, actualTargetNode);\n  } else if (name === \"aStar\") {\n    if (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\n    distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\n  } else {\n    distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\n  }\n\n  if (distanceToCompare < targetNode.distance) {\n    targetNode.distance = distanceToCompare;\n    targetNode.previousNode = currentNode;\n    targetNode.path = distance[1];\n    targetNode.direction = distance[2];\n\n    if (name === \"aStar\") {\n      targetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\n    }\n  }\n}\n\nfunction getNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => neighbor.stutus !== \"visited\");\n}\n\nfunction getDistance(nodeOne, nodeTwo) {\n  let x1 = nodeOne.row;\n  let y1 = nodeOne.col;\n  let x2 = nodeTwo.row;\n  let y2 = nodeTwo.col;\n\n  if (x2 < x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [1, [\"f\"], \"up\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"l\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [3, [\"r\", \"r\", \"f\"], \"up\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"up\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"up\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"up\"];\n    }\n  } else if (x2 > x1 && y1 === y2) {\n    if (nodeOne.direction === \"up\") {\n      return [3, [\"r\", \"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [2, [\"r\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [2, [\"l\", \"f\"], \"down\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [1, [\"f\"], \"down\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"down\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"down\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"down\"];\n    }\n  }\n\n  if (y2 < y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [3, [\"l\", \"l\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [1, [\"f\"], \"left\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"r\", \"f\"], \"left\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [2.5, null, \"left\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [1.5, null, \"left\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [1.5, null, \"left\"];\n    }\n  } else if (y2 > y1 && x1 === x2) {\n    if (nodeOne.direction === \"up\") {\n      return [2, [\"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"right\") {\n      return [1, [\"f\"], \"right\"];\n    } else if (nodeOne.direction === \"left\") {\n      return [3, [\"r\", \"r\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"down\") {\n      return [2, [\"l\", \"f\"], \"right\"];\n    } else if (nodeOne.direction === \"up-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-right\") {\n      return [1.5, null, \"right\"];\n    } else if (nodeOne.direction === \"up-left\") {\n      return [2.5, null, \"right\"];\n    } else if (nodeOne.direction === \"down-left\") {\n      return [2.5, null, \"right\"];\n    }\n  }\n}\n\nfunction manhattanDistance(nodeOne, nodeTwo) {\n  let nodeOneCoordinates = [nodeOne.row, nodeOne.col];\n  let nodeTwoCoordinates = [nodeTwo.row, nodeTwo.col];\n  let xChange = Math.abs(nodeOneCoordinates[0] - nodeTwoCoordinates[0]);\n  let yChange = Math.abs(nodeOneCoordinates[1] - nodeTwoCoordinates[1]);\n  return xChange + yChange;\n}","map":{"version":3,"sources":["C:/Users/Afraa/Documents/3D-Pathfinding-Visualizer/src/components/algorithms/weightedSearchAlgorithm.js"],"names":["getAllNodes","weightedSearchAlgorithm","grid","start","target","nodesToAnimate","name","heuristic","distance","direction","totalDistance","unvisitedNodes","length","currentNode","closestNode","status","Infinity","push","id","updateNeighbors","currentClosest","index","i","heuristicDistance","splice","node","neighbors","getNeighbors","neighbor","updateNode","targetNode","actualStartNode","actualTargetNode","getDistance","distanceToCompare","weight","manhattanDistance","Math","pow","previousNode","path","col","row","filter","stutus","nodeOne","nodeTwo","x1","y1","x2","y2","nodeOneCoordinates","nodeTwoCoordinates","xChange","abs","yChange"],"mappings":"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","sourcesContent":["import { getAllNodes } from './helpers.js';\r\n\r\nexport function weightedSearchAlgorithm(grid, start, target, nodesToAnimate, name, heuristic) {\r\n  // Initialze nodes\r\n\tstart.distance = 0;\r\n\tstart.direction = \"right\";\r\n\tif(name === \"aStar\") {\r\n\t\tstart.totalDistance = 0;\r\n\t}\r\n\t// Should be a Priority Queue\r\n  let unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length) {\r\n        let currentNode = closestNode(unvisitedNodes, name);\r\n    while (currentNode.status === \"wall\" && unvisitedNodes.length) {\r\n        currentNode = closestNode(unvisitedNodes, name)\r\n    }\r\n    if (currentNode.distance === Infinity) return false;\r\n    nodesToAnimate.push(currentNode);\r\n    //if(currentNode.status !== \"start\" && currentNode.status !== \"finish\"){\r\n      currentNode.status = \"visited\";\r\n    //}\r\n    // Ending condition\r\n\t\tif (currentNode.id === target.id) return \"success!\";\r\n\t\t// Updating neighbors\r\n    if (name === \"CLA\" || name === \"greedy\" || name === \"aStar\") {\r\n      updateNeighbors(grid, currentNode, start, target, name, heuristic);\r\n    } else if (name === \"Dijkstra\") {\r\n      updateNeighbors(grid, currentNode);\r\n    }\r\n  }\r\n}\r\n\r\nfunction closestNode(unvisitedNodes, name) {\r\n  let currentClosest, index;\r\n  for (let i = 0; i < unvisitedNodes.length; i++) {\r\n\t\tif(name === \"aStar\") {\r\n\t\t\tif (!currentClosest || currentClosest.totalDistance > unvisitedNodes[i].totalDistance) {\r\n\t\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\t\tindex = i;\r\n\t\t\t} else if (currentClosest.totalDistance === unvisitedNodes[i].totalDistance) {\r\n\t\t\t\tif (currentClosest.heuristicDistance > unvisitedNodes[i].heuristicDistance) {\r\n\t\t\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\t\t\tindex = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (!currentClosest || currentClosest.distance > unvisitedNodes[i].distance) {\r\n\t\t\t\tcurrentClosest = unvisitedNodes[i];\r\n\t\t\t\tindex = i;\r\n\t\t\t}\r\n\t\t}\r\n  }\r\n  unvisitedNodes.splice(index, 1);\r\n  return currentClosest;\r\n}\r\n\r\nfunction updateNeighbors(grid, node, start, target, name, heuristic) {\r\n  let neighbors = getNeighbors(node, grid);\r\n  for (let neighbor of neighbors) {\r\n    if (target) {\r\n      updateNode(node, neighbor, start, target, name, heuristic);\r\n    } else {\r\n      updateNode(node, neighbor);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nfunction updateNode(currentNode, targetNode, actualStartNode, actualTargetNode, name, heuristic) {\r\n  let distance = getDistance(currentNode, targetNode);\r\n  let distanceToCompare;\r\n  if (actualTargetNode && name === \"CLA\") {\r\n    let weight = targetNode.weight === 15 ? 15 : 1;\r\n    if (heuristic === \"manhattanDistance\") {\r\n      distanceToCompare = currentNode.distance + (distance[0] + weight) * manhattanDistance(targetNode, actualTargetNode);\r\n    } else if (heuristic === \"poweredManhattanDistance\") {\r\n      distanceToCompare = currentNode.distance + targetNode.weight + distance[0] + Math.pow(manhattanDistance(targetNode, actualTargetNode), 2);\r\n    } else if (heuristic === \"extraPoweredManhattanDistance\") {\r\n      distanceToCompare = currentNode.distance + (distance[0] + weight) * Math.pow(manhattanDistance(targetNode, actualTargetNode), 7);\r\n    }\r\n  } else if (actualTargetNode && name === \"greedy\") {\r\n    distanceToCompare = targetNode.weight + distance[0] + manhattanDistance(targetNode, actualTargetNode);\r\n  } else if(name === \"aStar\") {\r\n\t\tif (!targetNode.heuristicDistance) targetNode.heuristicDistance = manhattanDistance(targetNode, actualTargetNode);\r\n\t\tdistanceToCompare = currentNode.distance + targetNode.weight + distance[0];\r\n\t} else {\r\n    distanceToCompare = currentNode.distance + targetNode.weight + distance[0];\r\n  }\r\n  if (distanceToCompare < targetNode.distance) {\r\n    targetNode.distance = distanceToCompare;\r\n    targetNode.previousNode = currentNode;\r\n    targetNode.path = distance[1];\r\n\t\ttargetNode.direction = distance[2];\r\n\t\tif(name === \"aStar\") {\r\n\t\t\ttargetNode.totalDistance = targetNode.distance + targetNode.heuristicDistance;\r\n\t\t}\r\n  }\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n\tconst neighbors = [];\r\n\tconst {col, row} = node;\r\n\tif (row > 0) neighbors.push(grid[row - 1][col]);\r\n\tif (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n\tif (col > 0) neighbors.push(grid[row][col - 1]);\r\n\tif (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\treturn neighbors.filter(neighbor => neighbor.stutus !== \"visited\");\r\n}\r\n\r\n\r\nfunction getDistance(nodeOne, nodeTwo) {\r\n  let x1 = nodeOne.row;\r\n  let y1 = nodeOne.col;\r\n  let x2 = nodeTwo.row;\r\n  let y2 = nodeTwo.col;\r\n\tif (x2 < x1 && y1 === y2) {\r\n    if (nodeOne.direction === \"up\") {\r\n      return [1, [\"f\"], \"up\"];\r\n    } else if (nodeOne.direction === \"right\") {\r\n      return [2, [\"l\", \"f\"], \"up\"];\r\n    } else if (nodeOne.direction === \"left\") {\r\n      return [2, [\"r\", \"f\"], \"up\"];\r\n    } else if (nodeOne.direction === \"down\") {\r\n      return [3, [\"r\", \"r\", \"f\"], \"up\"];\r\n    } else if (nodeOne.direction === \"up-right\") {\r\n      return [1.5, null, \"up\"];\r\n    } else if (nodeOne.direction === \"down-right\") {\r\n      return [2.5, null, \"up\"];\r\n    } else if (nodeOne.direction === \"up-left\") {\r\n      return [1.5, null, \"up\"];\r\n    } else if (nodeOne.direction === \"down-left\") {\r\n      return [2.5, null, \"up\"];\r\n    }\r\n  } else if (x2 > x1 && y1 === y2) {\r\n    if (nodeOne.direction === \"up\") {\r\n      return [3, [\"r\", \"r\", \"f\"], \"down\"];\r\n    } else if (nodeOne.direction === \"right\") {\r\n      return [2, [\"r\", \"f\"], \"down\"];\r\n    } else if (nodeOne.direction === \"left\") {\r\n      return [2, [\"l\", \"f\"], \"down\"];\r\n    } else if (nodeOne.direction === \"down\") {\r\n      return [1, [\"f\"], \"down\"];\r\n    } else if (nodeOne.direction === \"up-right\") {\r\n      return [2.5, null, \"down\"];\r\n    } else if (nodeOne.direction === \"down-right\") {\r\n      return [1.5, null, \"down\"];\r\n    } else if (nodeOne.direction === \"up-left\") {\r\n      return [2.5, null, \"down\"];\r\n    } else if (nodeOne.direction === \"down-left\") {\r\n      return [1.5, null, \"down\"];\r\n    }\r\n  }\r\n  if (y2 < y1 && x1 === x2) {\r\n    if (nodeOne.direction === \"up\") {\r\n      return [2, [\"l\", \"f\"], \"left\"];\r\n    } else if (nodeOne.direction === \"right\") {\r\n      return [3, [\"l\", \"l\", \"f\"], \"left\"];\r\n    } else if (nodeOne.direction === \"left\") {\r\n      return [1, [\"f\"], \"left\"];\r\n    } else if (nodeOne.direction === \"down\") {\r\n      return [2, [\"r\", \"f\"], \"left\"];\r\n    } else if (nodeOne.direction === \"up-right\") {\r\n      return [2.5, null, \"left\"];\r\n    } else if (nodeOne.direction === \"down-right\") {\r\n      return [2.5, null, \"left\"];\r\n    } else if (nodeOne.direction === \"up-left\") {\r\n      return [1.5, null, \"left\"];\r\n    } else if (nodeOne.direction === \"down-left\") {\r\n      return [1.5, null, \"left\"];\r\n    }\r\n  } else if (y2 > y1 && x1 === x2) {\r\n    if (nodeOne.direction === \"up\") {\r\n      return [2, [\"r\", \"f\"], \"right\"];\r\n    } else if (nodeOne.direction === \"right\") {\r\n      return [1, [\"f\"], \"right\"];\r\n    } else if (nodeOne.direction === \"left\") {\r\n      return [3, [\"r\", \"r\", \"f\"], \"right\"];\r\n    } else if (nodeOne.direction === \"down\") {\r\n      return [2, [\"l\", \"f\"], \"right\"];\r\n    } else if (nodeOne.direction === \"up-right\") {\r\n      return [1.5, null, \"right\"];\r\n    } else if (nodeOne.direction === \"down-right\") {\r\n      return [1.5, null, \"right\"];\r\n    } else if (nodeOne.direction === \"up-left\") {\r\n      return [2.5, null, \"right\"];\r\n    } else if (nodeOne.direction === \"down-left\") {\r\n      return [2.5, null, \"right\"];\r\n    }\r\n  } \r\n}\r\n\r\nfunction manhattanDistance(nodeOne, nodeTwo) {\r\n  let nodeOneCoordinates = [nodeOne.row, nodeOne.col];\r\n  let nodeTwoCoordinates = [nodeTwo.row, nodeTwo.col]\r\n  let xChange = Math.abs(nodeOneCoordinates[0] - nodeTwoCoordinates[0]);\r\n  let yChange = Math.abs(nodeOneCoordinates[1] - nodeTwoCoordinates[1]);\r\n  return (xChange + yChange);\r\n}"]},"metadata":{},"sourceType":"module"}